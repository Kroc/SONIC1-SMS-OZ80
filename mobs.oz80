;; Sonic 1 Master System Disassembly
   -------------------------------------------------------------------------------------------------
   created by Kroc Camen <kroc@camendesign.com> and given to the Public Domain; you may do anything
   you like with this code as long as you respect the TradeMarks and (any) Copyrights within.
   absolutely no warranty implied
   =================================================================================================
;;

TYPE    #mob                        ;26 bytes
;===================================================================================================
HELP    ``The data-structure for a mob (Movable Object Block); the game's objects and enemies
[
        .type                       BYTE                    ;IX+$00    - the object type index number
        .Xsubpixel                  BYTE                    ;IX+$01    - sub-pixel accuracy of X position
        .X                          WORD                    ;IX+$02/03 - in px
        .Ysubpixel                  BYTE                    ;IX+$04    - sub-pixel accuracy of Y position
        .Y                          WORD                    ;IX+$05/06 - in px
        .Xspeed                     WORD                    ;IX+$07/08 - in px, signed (i.e. $F??? = left)
        .Xdirection                 BYTE                    ;IX+$09    - $FF for left, else $00
        .Yspeed                     WORD                    ;IX+$0A/0B - in px, signed  (i.e. $F??? = up)
        .Ydirection                 BYTE                    ;IX+$0C    - $FF for up, else $00
        .width                      BYTE                    ;IX+$0D    - in px
        .height                     BYTE                    ;IX+$0E    - in px
        .spriteLayout               WORD                    ;IX+$0F/10 - address to current sprite layout
        .unknown11                  BYTE    
        .unknown12                  BYTE    
        .unknown13                  BYTE    
        .unknown14                  BYTE    
        .unknown15                  BYTE    
        .unknown16                  BYTE    
        .unknown17                  BYTE    
        .flags                      TYPE [                  ;various mob flags
                .unknown0           BOOL
                .unknown1           BOOL
                .unknown2           BOOL
                .unknown3           BOOL
                .underwater         BOOL                    ;4 - underwater flag
                .noCollision        BOOL                    ;5 - whether the mob adheres to the floor or not
                .unknown6           BOOL
                .unknown7           BOOL
                                    ]
        .unknown19                  BYTE                    ;unused?
]

;mobs: the 32 mobs in the level begin here:
;---------------------------------------------------------------------------------------------------
RAM     ;name                       ;size                                                   ;addr
[
        ;the player is a mob like any other and has reserved parameters in memory
        .SONIC                      TYPE #mob                                               ;$D3FC
                                    ;.type                                                  ;$D3FC
                                    ;.Xsubpixel                                             ;$D3FD
                                    ;.X                                                     ;$D3FE
                                    ;.Ysubpixel                                             ;$D400
                                    ;.Y                                                     ;$D401
                                    ;.Xspeed                                                ;$D403
                                    ;.Xdirection                                            ;$D405
                                    ;.Yspeed                                                ;$D406
                                    ;.Ydirecton                                             ;$D408
                                    ;.width                                                 ;$D409
                                    ;.height                                                ;$D40A
                                    ;.spriteLayout                                          ;$D40B
                                    ;.unknown11                                             ;$D40D
                                    ;.unknown12                                             ;$D40E
                                    ;.unknown13                                             ;$D40F
                                    ;.unknown14                                             ;$D410
                                    ;.unknown15                                             ;$D411
                                    ;.unknown16                                             ;$D412
                                    ;.unknown17                                             ;$D413
                                    ;.flags                                                 ;$D414
                                    ;.unknown19                                             ;$D415
                            
        ;remaining 31 mobs are here
        .MOBS                       BYTE x (#mob.size * 31)                                 ;$D416-
                                                                                            ;$D73C
]

;---------------------------------------------------------------------------------------------------
                    
TABLE   :mobPointers                ENUM !MOBS              SECTION ::mobs                  ;$2AF6         

;TODO: move these to their respective places
ROW     .powerUp_ring                                       TABLE :mobPointers              ;=$01
{       ;$01            
        WORD    :mob_powerUp_ring           
}           
ROW     .powerUp_speed                                      TABLE :mobPointers
{       ;$02            
        WORD    :mob_powerUp_speed          
}           
ROW     .powerUp_life                                       TABLE :mobPointers
{       ;$03            
        WORD    :mob_powerUp_life           
}           
ROW     .powerUp_shield                                     TABLE :mobPointers
{       ;$04            
        WORD    :mob_powerUp_shield         
}           
ROW     .powerUp_invincibility                              TABLE :mobPointers
{           
        WORD    :mob_powerUp_invincibility                  ;#05: monitor - invincibility
}           
ROW     .powerUp_shield                                     TABLE :mobPointers
{           
        WORD    :mob_powerUp_emerald                        ;#06: chaos emerald
}           
ROW     .boss_endSign                                       TABLE :mobPointers
{                   
        WORD    :mob_boss_endSign                           ;#07: end sign
}           
ROW     .badnick_crabMeat                                   TABLE :mobPointers
{           
        WORD    :mob_badnick_crabMeat                       ;#08: badnick - crabmeat
}           
ROW     .platform_swinging                                  TABLE :mobPointers
{           
        WORD    :mob_platform_swinging                      ;#09: wooden platform - swinging (Green Hill)
}           
ROW     .explosion                                          TABLE :mobPointers
{           
        WORD    :mob_explosion                              ;#0A: explosion
}           
ROW     .platform                                           TABLE :mobPointers
{           
        WORD    :mob_platform                               ;#0B: wooden platform (Green Hill)
}           
ROW     .platform_weight                                    TABLE :mobPointers
{           
        WORD    :mob_platform_weight                        ;#0C: wooden platform - falling (Green Hill)
}           
ROW     ._6ac1                                              TABLE :mobPointers
{           
        WORD    :_6ac1                                      ;#0D: UNKNOWN
}           
ROW     .badnick_buzzBomber                                 TABLE :mobPointers
{           
        WORD    :mob_badnick_buzzBomber                     ;#0E: badnick - buzz bomber
}           
ROW     .platform_leftRight                                 TABLE :mobPointers
{           
        WORD    :mob_platform_leftRight                     ;#0F: wooden platform - moving (Green Hill)
}           
ROW     .badnick_motobug                                    TABLE :mobPointers
{           
        WORD    :mob_badnick_motobug                        ;#10: badnick - motobug
}           
ROW     .badnick_newtron                                    TABLE :mobPointers
{           
        WORD    :mob_badnick_newtron                        ;#11: badnick - newtron
}           
ROW     .boss_greenHill                                     TABLE :mobPointers
{           
        WORD    :mob_boss_greenHill                         ;#12: boss (Green Hill)
}
ROW     ._9b75                                              TABLE :mobPointers
{      
        WORD    :_9b75                                      ;#13: UNKNOWN - bullet?
}
ROW     ._9be8                                              TABLE :mobPointers
{
        WORD    :_9be8                                      ;#14: UNKNOWN - fireball right?
}
ROW     ._9c70                                              TABLE :mobPointers
{
        WORD    :_9c70                                      ;#15: UNKNOWN - fireball left?
}
ROW     .trap_flameThrower                                  TABLE :mobPointers
{
        WORD    :mob_trap_flameThrower                      ;#16: flame thrower (Scrap Brain)
}
ROW     .door_left                                          TABLE :mobPointers
{
        WORD    :mob_door_left                              ;#17: door - one way left (Scrap Brain)
}
ROW     .door_right                                         TABLE :mobPointers
{
        WORD    :mob_door_right                             ;#18: door - one way right (Scrap Brain)
}
ROW     .door_door                                          TABLE :mobPointers
{
        WORD    :mob_door                                   ;#19: door (Scrap Brain)
}
ROW     .trap_electric                                      TABLE :mobPointers
{
        WORD    :mob_trap_electric                          ;#1A: electric sphere (Scrap Brain)
}
ROW     .badnick_ballHog                                    TABLE :mobPointers
{
        WORD    :mob_badnick_ballHog                        ;#1B: badnick - ball hog (Scrap Brain)
}
ROW     ._a33c                                              TABLE :mobPointers
{
        WORD    :_a33c                                      ;#1C: UNKNOWN - ball from ball hog?
}
ROW     .switch                                             TABLE :mobPointers
{
        WORD    :mob_switch                                 ;#1D: switch
}
ROW     .door_switchActivated                               TABLE :mobPointers
{
        WORD    :mob_door_switchActivated                   ;#1E: switch door
}
ROW     .badnick_caterkiller                                TABLE :mobPointers
{
        WORD    :mob_badnick_caterkiller                    ;#1F: badnick - caterkiller
}
ROW     ._96f8                                              TABLE :mobPointers
{
        WORD    :_96f8                                      ;#20: UNKNOWN
}
ROW     .platform_bumper                                    TABLE :mobPointers
{
        WORD    :mob_platform_bumper                        ;#21: moving bumper (Special Stage)
}
ROW     .boss_scrapBrain                                    TABLE :mobPointers
{
        WORD    :mob_boss_scrapBrain                        ;#22: boss (Scrap Brain)
}
ROW     .boss_freeRabbit                                    TABLE :mobPointers
{
        WORD    :mob_boss_freeRabbit                        ;#23: free animal - rabbit
}
ROW     .boss_freeBird                                      TABLE :mobPointers
{
        WORD    :mob_boss_freeBird                          ;#24: free animal - bird
}
ROW     .boss_capsule                                       TABLE :mobPointers
{
        WORD    :mob_boss_capsule                           ;#25: capsule
}
ROW     .badnick_chopper                                    TABLE :mobPointers
{
        WORD    :mob_badnick_chopper                        ;#26: badnick - chopper
}
ROW     .platform_fallVert                                  TABLE :mobPointers
{
        WORD    :mob_platform_fallVert                      ;#27: log - vertical (Jungle)
}
ROW     .platform_fallHoriz                                 TABLE :mobPointers
{
        WORD    :mob_platform_fallHoriz                     ;#28: log - horizontal (Jungle)
}
ROW     .platform_roll                                      TABLE :mobPointers
{
        WORD    :mob_platform_roll                          ;#29: log - floating (Jungle)
}
ROW     ._96a8                                              TABLE :mobPointers
{
        WORD    :_96a8                                      ;#2A: UNKNOWN
}
ROW     ._8218                                              TABLE :mobPointers
{
        WORD    :_8218                                      ;#2B: UNKNOWN
}
ROW     .boss_jungle                                        TABLE :mobPointers
{
        WORD    :mob_boss_jungle                            ;#2C: boss (Jungle)
}
ROW     .badnick_yadrin                                     TABLE :mobPointers
{
        WORD    :mob_badnick_yadrin                         ;#2D: badnick - yadrin (Bridge)
}
ROW     .platform_bridge                                    TABLE :mobPointers
{
        WORD    :mob_platform_bridge                        ;#2E: falling bridge (Bridge)
}
ROW     ._94a5                                              TABLE :mobPointers
{
        WORD    :_94a5                                      ;#2F: UNKNOWN - wave moving projectile?
}
ROW     .meta_clouds                                        TABLE :mobPointers
{
        WORD    :mob_meta_clouds                            ;#30: meta - clouds (Sky Base)
}
ROW     .trap_propeller                                     TABLE :mobPointers
{
        WORD    :mob_trap_propeller                         ;#31: propeller (Sky Base)
}
ROW     .badnick_bomb                                       TABLE :mobPointers
{
        WORD    :mob_badnick_bomb                           ;#32: badnick - bomb (Sky Base)
}
ROW     .trap_cannon                                        TABLE :mobPointers
{
        WORD    :mob_trap_cannon                            ;#33: cannon (Sky Base)
}
ROW     .trap_cannonBall                                    TABLE :mobPointers
{
        WORD    :mob_trap_cannonBall                        ;#34: cannon ball (Sky Base)
}
ROW     .badnick_unidos                                     TABLE :mobPointers
{
        WORD    :mob_badnick_unidos                         ;#35: badnick - unidos (Sky Base)
}
ROW     ._b0f4                                              TABLE :mobPointers
{
        WORD    :_b0f4                                      ;#36: UNKNOWN - stationary, lethal
}
ROW     .trap_turretRotating                                TABLE :mobPointers
{
        WORD    :mob_trap_turretRotating                    ;#37: rotating turret (Sky Base)
}
ROW     .platform_flyingRight                               TABLE :mobPointers
{
        WORD    :mob_platform_flyingRight                   ;#38: flying platform (Sky Base)
}
ROW     ._b398                                              TABLE :mobPointers
{
        WORD    :_b398                                      ;#39: moving spiked wall (Sky Base)
}
ROW     .trap_turretFixed                                   TABLE :mobPointers
{
        WORD    :mob_trap_turretFixed                       ;#3A: fixed turret (Sky Base)
}
ROW     .platform_flyingUpDown                              TABLE :mobPointers
{
        WORD    :mob_platform_flyingUpDown                  ;#3B: flying platform - up/down (Sky Base)
}
ROW     .badnick_jaws                                       TABLE :mobPointers
{
        WORD    :mob_badnick_jaws                           ;#3C: badnick - jaws (Labyrinth)
}
ROW     .trap_spikeBall                                     TABLE :mobPointers
{
        WORD    :mob_trap_spikeBall                         ;#3D: spike ball (Labyrinth)
}
ROW     .trap_spear                                         TABLE :mobPointers
{
        WORD    :mob_trap_spear                             ;#3E: spear (Labyrinth)
}
ROW     .trap_fireball                                      TABLE :mobPointers
{
        WORD    :mob_trap_fireball                          ;#3F: fire ball head (Labyrinth)
}
ROW     .meta_water                                         TABLE :mobPointers
{
        WORD    :mob_meta_water                             ;#40: meta - water line position
}
ROW     .powerUp_bubbles                                    TABLE :mobPointers
{
        WORD    :mob_powerUp_bubbles                        ;#41: bubbles (Labyrinth)
}
ROW     ._8eca                                              TABLE :mobPointers
{
        WORD    :_8eca                                      ;#42: UNKNOWN
}
ROW     .null                                               TABLE :mobPointers
{
        WORD    :mob_null                                   ;#43: NO-CODE
}
ROW     .badnick_burrobot                                   TABLE :mobPointers
{
        WORD    :mob_badnick_burrobot                       ;#44: badnick - burrobot
}
ROW     .platform_float                                     TABLE :mobPointers
{
        WORD    :mob_platform_float                         ;#45: platform - float up (Labyrinth)
}
ROW     .boss_electricBeam                                  TABLE :mobPointers
{
        WORD    :mob_boss_electricBeam                      ;#46: boss - electric beam (Sky Base)
}
ROW     ._bcdf                                              TABLE :mobPointers
{
        WORD    :_bcdf                                      ;#47: UNKNOWN
}
ROW     .boss_bridge                                        TABLE :mobPointers
{
        WORD    :mob_boss_bridge                            ;#48: boss (Bridge)
}
ROW     .boss_labyrinth                                     TABLE :mobPointers
{
        WORD    :mob_boss_labyrinth                         ;#49: boss (Labyrinth)
}
ROW     .boss_skybase                                       TABLE :mobPointers
{
        WORD    :mob_boss_skyBase                           ;#4A: boss (Sky Base)
}
ROW     .meta_trip                                          TABLE :mobPointers
{
        WORD    :mob_meta_trip                              ;#4B: trip zone (Green Hill)
}
ROW     .platform_flipper                                   TABLE :mobPointers
{
        WORD    :mob_platform_flipper                       ;#4C: Flipper (Special Stage)
}
ROW     .                                                   TABLE :mobPointers
{
        WORD    $0000                                       ;#4D: RESET!
}
ROW     .platform_balance                                   TABLE :mobPointers
{
        WORD    :mob_platform_balance                       ;#4E: balance (Bridge)
}
ROW     .                                                   TABLE :mobPointers
{
        WORD    $0000                                       ;#4F: RESET!
}
ROW     .flower                                             TABLE :mobPointers
{        
        WORD    :mob_flower                                 ;#50: flower (Green Hill)
}
ROW     .powerUp_checkpoint                                 TABLE :mobPointers
{
        WORD    :mob_powerUp_checkpoint                     ;#51: monitor - checkpoint
}
ROW     .powerUp_continue                                   TABLE :mobPointers
{           
        WORD    :mob_powerUp_continue                       ;#52: monitor - continue
}           
ROW     .anim_final                                         TABLE :mobPointers
{           
        WORD    :mob_anim_final                             ;#53: final animation
}           
ROW     .anim_emeralds                                      TABLE :mobPointers
{           
        WORD    :mob_anim_emeralds                          ;#54: all emeralds animation
}           
ROW     ._7b95                                              TABLE :mobPointers
{           
        WORD    :_7b95                                      ;#55: "make sonic blink"
}


;TODO: move these rows to the individual mob files
TABLE   :mobBounds                                          SECTION ::mobs                  ;$2BA2
;===================================================================================================
{       ;;      1.  the X-distance the mob can be left of the camera without despawning 
                2.  the X-distance the mob can be right of the camera without despawning
                    NOTE: this has to include the screen width of $0100 (256)
                3.  the Y-distance the mob can be above the camera without despawning
                4.  the Y-distance the mob can be below of the camera without despawning
                    NOTE: this has to include the screen height of $00C0 (192)
        ;;
        WORD    $0100 $0200 $0100 $0200                     ;#00: Sonic
        WORD    $0020 $0120 $0020 $00E0                     ;#01: monitor - ring
        WORD    $0020 $0120 $0020 $00E0                     ;#02: monitor - speed shoes
        WORD    $0020 $0120 $0020 $00E0                     ;#03: monitor - life
        WORD    $0020 $0120 $0020 $00E0                     ;#04: monitor - shield
        WORD    $0020 $0120 $0020 $00E0                     ;#05: monitor - invincibility
        WORD    $0020 $0120 $0020 $00E0                     ;#06: chaos emerald
        WORD    $0020 $0120 $0060 $00E0                     ;#07: end sign
        WORD    $0010 $0110 $0020 $00E0                     ;#08: badnick - crabmeat
        WORD    $00A0 $01A0 $0040 $0100                     ;#09: wooden platform - swinging (Green Hill)
        WORD    $0040 $0140 $0040 $0100                     ;#0A: explosion
        WORD    $0020 $0120 $0020 $00E0                     ;#0B: wooden platform (Green Hill)
        WORD    $0020 $0120 $0030 $00F0                     ;#0C: wooden platform - falling (Green Hill)
        WORD    $0100 $0200 $0100 $01C0                     ;#0D: UNKNOWN
        WORD    $0040 $0140 $0040 $0100                     ;#0E: badnick - buzz bomber
        WORD    $00A0 $01A0 $0020 $00E0                     ;#0F: wooden platform - moving (Green Hill)
        WORD    $0010 $0110 $0010 $00D0                     ;#10: badnick - motobug
        WORD    $0010 $0110 $0010 $00D0                     ;#11: badnick - newtron
        WORD    $00C0 $01C0 $0080 $0140                     ;#12: boss (Green Hill)
        WORD    $0020 $0120 $0020 $00E0                     ;#13: UNKNOWN - bullet?
        WORD    $0008 $0140 $0010 $00D0                     ;#14: UNKNOWN - fireball right?
        WORD    $0040 $0108 $0010 $00D0                     ;#15: UNKNOWN - fireball left?
        WORD    $0010 $0110 $0020 $00E0                     ;#16: flame thrower (Scrap Brain)
        WORD    $0020 $0120 $0030 $00CC                     ;#17: door - one way left (Scrap Brain)
        WORD    $0020 $0120 $0030 $00CC                     ;#18: door - one way right (Scrap Brain)
        WORD    $0020 $0120 $0030 $00CC                     ;#19: door (Scrap Brain)
        WORD    $0020 $0120 $0020 $00DA                     ;#1A: electric sphere (Scrap Brain)
        WORD    $0030 $0130 $0030 $00F0                     ;#1B: badnick - ball hog (Scrap Brain)
        WORD    $0100 $0180 $0100 $01C0                     ;#1C: UNKNOWN - ball from ball hog?
        WORD    $0010 $0110 $0010 $00D0                     ;#1D: switch
        WORD    $0020 $0120 $0030 $00C8                     ;#1E: switch door
        WORD    $0020 $0120 $0020 $00E0                     ;#1F: badnick - caterkiller
        WORD    $0020 $0120 $0020 $00E0                     ;#20: UNKNOWN
        WORD    $0020 $0120 $0080 $0140                     ;#21: moving bumper (Special Stage)
        WORD    $0010 $0110 $0080 $00F0                     ;#22: boss (Scrap Brain)
        WORD    $0020 $0120 $0010 $00D0                     ;#23: free animal - rabbit
        WORD    $0020 $0120 $0010 $00D0                     ;#24: free animal - bird
        WORD    $0020 $0120 $0020 $00E0                     ;#25: capsule
        WORD    $0010 $0110 $0060 $0100                     ;#26: badnick - chopper
        WORD    $0028 $0128 $0100 $01C0                     ;#27: log - vertical (Jungle)
        WORD    $0028 $0128 $0100 $01C0                     ;#28: log - horizontal (Jungle)
        WORD    $0010 $0110 $0010 $00D0                     ;#29: log - floating (Jungle)
        WORD    $0020 $0120 $0020 $00E0                     ;#2A: UNKNOWN
        WORD    $0010 $0110 $0010 $00D0                     ;#2B: UNKNOWN
        WORD    $0040 $0140 $00C0 $0180                     ;#2C: boss (Jungle)
        WORD    $0010 $0110 $0010 $00D0                     ;#2D: badnick - yadrin (Bridge)
        WORD    $0080 $0180 $0040 $01C0                     ;#2E: falling bridge (Bridge)
        WORD    $0020 $0120 $0020 $00E0                     ;#2F: UNKNOWN - wave moving projectile?
        WORD    $0800 $0800 $0030 $00F0                     ;#30: meta - clouds (Sky Base)
        WORD    $0010 $0110 $0020 $00E0                     ;#31: propeller (Sky Base)
        WORD    $0020 $0120 $0020 $00E0                     ;#32: badnick - bomb (Sky Base)
        WORD    $0000 $0100 $0000 $00C0                     ;#33: cannon (Sky Base)
        WORD    $0200 $0300 $0200 $02C0                     ;#34: cannon ball (Sky Base)
        WORD    $0010 $0110 $0010 $00D0                     ;#35: badnick - unidos (Sky Base)
        WORD    $0040 $0140 $0040 $0100                     ;#36: UNKNOWN - stationary, lethal
        WORD    $0010 $0110 $0010 $00D0                     ;#37: rotating turret (Sky Base)
        WORD    $0040 $0140 $0020 $00E0                     ;#38: flying platform (Sky Base)
        WORD    $0080 $0180 $0050 $00D0                     ;#39: moving spiked wall (Sky Base)
        WORD    $0010 $0110 $0010 $00D0                     ;#3A: fixed turret (Sky Base)
        WORD    $0010 $0110 $0060 $0120                     ;#3B: flying platform - up/down (Sky Base)
        WORD    $0010 $0110 $0010 $00D0                     ;#3C: badnick - jaws (Labyrinth)
        WORD    $0060 $0160 $0060 $0120                     ;#3D: spike ball (Labyrinth)
        WORD    $0010 $0110 $0010 $00D0                     ;#3E: spear (Labyrinth)
        WORD    $0020 $0120 $0020 $00E0                     ;#3F: fire ball head (Labyrinth)
        WORD    $2000 $2100 $0020 $00E0                     ;#40: meta - water line position
        WORD    $0008 $0108 $0008 $00C8                     ;#41: bubbles (Labyrinth)
        WORD    $0020 $0120 $0020 $00E0                     ;#42: UNKNOWN
        WORD    $0020 $0120 $0020 $00E0                     ;#43: NO-CODE
        WORD    $0020 $0120 $0020 $00E0                     ;#44: badnick - burrobot
        WORD    $0028 $0128 $0028 $00E8                     ;#45: platform - float up (Labyrinth)
        WORD    $0060 $0160 $0020 $00E0                     ;#46: boss - electric beam (Sky Base)
        WORD    $0100 $0200 $0100 $01C0                     ;#47: UNKNOWN
        WORD    $0010 $0110 $0010 $00D0                     ;#48: boss (Bridge)
        WORD    $0010 $0110 $0100 $01C0                     ;#49: boss (Labyrinth)
        WORD    $0010 $0110 $0010 $00D0                     ;#4A: boss (Sky Base)
        WORD    $0010 $0110 $0010 $00D0                     ;#4B: trip zone (Green Hill)
        WORD    $0020 $0120 $0020 $00E0                     ;#4C: Flipper (Special Stage)
        WORD    $0020 $0120 $0020 $00E0                     ;#4D: RESET!
        WORD    $0038 $0128 $0030 $00F0                     ;#4E: balance (Bridge)
        WORD    $0020 $0120 $0020 $00E0                     ;#4F: RESET!
        WORD    $0010 $0110 $0010 $00D0                     ;#50: flower (Green Hill)
        WORD    $0020 $0120 $0020 $00E0                     ;#51: monitor - checkpoint
        WORD    $0020 $0120 $0020 $00E0                     ;#52: monitor - continue
        WORD    $0100 $01E0 $00C0 $0180                     ;#53: final animation
        WORD    $0100 $0200 $0100 $01C0                     ;#54: all emeralds animation
        WORD    $0800 $0900 $0800 $08C0                     ;#55: "make sonic blink"
}
;ring count HUD
TABLE   :_2e52                                              SECTION ::mobs                  ;$2E52
        ;===========================================================================================
{
        BYTE    $A6, $A8, $FF
}
;this is the sprite-layout for the lives display on levels
TABLE   :_2e55                                              SECTION ::mobs                  ;$2E55
        ;===========================================================================================
{
        BYTE    $A0, $A2, $A4, $00, $FF
}

PROC    :_2e5a                                              SECTION ::mobs                  ;$2E5A
        ;===========================================================================================
        ;; update display -- refreshes the lives & time display, updates the camera
           and processes all the mobs in the level ;;
        
PARAMS  IY`vars         ``Address of the common variables (used throughout)
{        
        ;do not update the Sonic sprite frame (upon Interrupt)
        res     7   [IY+#vars.timeLightningFlags]
        
        ;-------------------------------------------------------------------------------------------
        
        ;; populate the layout buffer with the bytes in the table above, 
           $A0, $A2, $A4, $00 $FF -- the Sonic icon, "x", and placeholder for lives ;;
        ld      HL                  :_2e55
        ld      DE                  $.LAYOUT_BUFFER
        ld      BC                  5
        ldir
        
        ld      A`lives             [$.LIVES]
        cp      9                                           ;9 lives?
        jr      c   ._1                                     ;if more than 9 lives,
        ld      A`lives             9                       ;we will display as 9 lives
        
._1     add     A`lives             A`lives                 ;double for the 8x16 sprite lookup                     
        add     A`lives             $80                     ;number sprites begin at index $80
        ld      [$.LAYOUT_BUFFER+3] A`lives                 ;put number of lives into the buffer
        
        ld      C`xpos              !HUD_LIVES_X            ;X-position of lives display
        ld      B`ypos              !HUD_LVIES_Y            ;Y-position of lives display
        ld      HL                  [$.SPRITETABLE_ADDR]
        ld      DE                  $.LAYOUT_BUFFER
        call    :layoutSpritesHorizontal
        ld      [$.SPRITETABLE_ADDR]    HL
        
        ;-------------------------------------------------------------------------------------------
        
        ;show rings?
        bit     2   [IY+#vars.scrollRingFlags]
        call    nz  :displayRingCount
        
        ;show time?
        bit     5   [IY+#vars.timeLightningFlags]
        call    nz  :displayTime
        
        ;-------------------------------------------------------------------------------------------
        
        ld      DE                  $0060
        ld      HL                  $.D267                  ;gets set by moving platforms, e.g. $20
        ld      A                   [HL]                    ;[$D267]
        inc     HL                                          ;$D268
        or      [HL]                                        ;[$D268]
        call    z   :_311a                                  ;=0?
      ;;ld      [HL]                D                       ;[$D268] = $60  ;write $6000?
        dec     HL                                          ;$D267          ;is this an address?
        ld      [HL]                E                       ;[$D267] = $00
        inc     HL;;                                        ;$D268
        
        inc     HL
        ld      DE                  $0088
        ld      A                   [HL]
        inc     HL
        or      [HL]
        call    z   :_311a
        
        inc     HL
        ld      DE                  $0060
        ld      A                   [HL]
        inc     HL
        or      [HL]
        call    z   :_311a
        
        inc     HL
        ld      DE                  $0070
        ;up-down wave scrolling?
        bit     6   [IY`vars+#vars.scrollRingFlags]
        jr      z   ._2
        ld      DE                  $0080
._2     ld      A                   [HL]
        inc     HL
        or      [HL]
        call    z   :_311a
        
        ;is Sonic alive?
        bit     0   [IY`vars+#vars.scrollRingFlags]    
        call    z   :_2f66                                  ;handle camera movement
        
        ld      HL`zero             $0000
        ld      [$.D267]            HL`zero
        ld      [$.D269]            HL`zero
        ld      [$.D26B]            HL`zero
        ld      [$.D26D]            HL`zero
        
        ;check for mobs that have gone too far off-screen and should be despawned
        call    :checkMobsOutOfBounds
        ;run the code for all the different mobs in the level (including the player)
        call    :doMobs
        
        ret
}

PROC    :displayRingCount                                   SECTION ::mobs                  ;$2EE6
        ;===========================================================================================
HELP  ``Update the player's ring-count on the screen
{        
        ld      A`rings             [$.RINGS]
        ld      C`rings             A`rings
        rrca    
        rrca    
        rrca    
        rrca    
        and     %00001111
        add     A                   A
        add     A                   $80
        ld      [$.LAYOUT_BUFFER]   A
        ld      A                   C
        and     %00001111
        add     A                   A
        add     A                   $80
        ld      [$.LAYOUT_BUFFER+1] A
        ld      A                   $FF
        ld      [$.LAYOUT_BUFFER+2] A
        
        ld      C`xpos              20
        ld      B`ypos              0
        ld      HL                  [$.SPRITETABLE_ADDR]
        ld      DE                  :_2e52
        call    :layoutSpritesHorizontal
        
        ld      C`xpos              40
        ld      B`ypos              0
        ld      DE                  $.LAYOUT_BUFFER
        call    :layoutSpritesHorizontal
        
        ld      [$.SPRITETABLE_ADDR]    HL
        
        ret
}

PROC    :displayTime                                        SECTION ::mobs                  ;$2F1F
        ;===========================================================================================
HELP  ``Draws the level time on the screen
{        
        ld      HL`buffer           $.LAYOUT_BUFFER
        
        ld      A`minutes           [$.TIME_MINUTES]
        and     %00001111
        add     A`tileIndex         A`minutes
        add     A`tileIndex         $80                     ;numeral 0 tile index
        
        ld      [HL`buffer]         A`tileIndex
        inc     HL`buffer
        ld      [HL`buffer]         $B0                     ;colon tile index
        inc     HL`buffer
        
        ;TODO: a look-up table has to be faster than this...
        ld      A`seconds           [$.TIME_SECONDS]
        ld      C                   A
        srl     A
        srl     A
        srl     A
        srl     A
        add     A                   A
        add     A                   $80
        ld      [HL`buffer]         A`tileIndex
        inc     HL`buffer
        
        ld      A                   C
        and     %00001111
        add     A                   A
        add     A                   $80
        ld      [HL]                A
        inc     HL  
        ld      [HL`buffer]         $FF                     ;terminate the buffer
        
        ld      C`xpos              24
        ld      B`ypos              16
        
        ;are we on the special stage?
        ld      A`level             [$.CURRENT_LEVEL]
        cp      28
        jr      c   ._1
        
        ;position the time in the centre of the screen on special stages
        ;TODO: this is inefficient changing the position twice
        ld      C`xpos              112
        ld      B`ypos              56
        
._1     ld      HL`spriteTable      [$.SPRITETABLE_ADDR]
        ld      DE`buffer           $.LAYOUT_BUFFER
        call    :layoutSpritesHorizontal
        ld      [$.SPRITETABLE_ADDR]    HL`spriteTable
        
        ret
}

        ;update camera? called only by ":_2e5a"
PROC    :_2f66                                              SECTION ::mobs                  ;$2F66
        ;===========================================================================================
PARAMS  IY`vars         ``Address of the common variables (used throughout)
{
        ;if scrolling is locked, do nothing
        bit     6   [IY+#vars.timeLightningFlags]
        ret     nz
        
        ;does the camera need to be moved horizontally toward a target?
        ld      HL                  [$.CAMERA_X_GOTO]
        ld      A                   L
        or      H
        call    nz  :scrollCameraTo_horizontal
        
        ;does the camera need to be moved vertically toward a target?
        ld      HL                  [$.CAMERA_Y_GOTO]
        ld      A                   L
        or      H
        call    nz  :scrollCameraTo_vertical
        
        ;-------------------------------------------------------------------------------------------
        
        ;;I believe this bit is to do with getting Sonic and the camera to move with
          along with another mob, such as a moving platform;;
        
        ld      HL                  [$.D267]                ;gets set by the mob
        ld      DE                  [$.D25F]                ;gets set by Sonic
        and     A                                           ;clear flags, particularly carry
        sbc     HL                  DE 
        call    nz  :_315e
        ld      [$.D25F]            DE
        
        ld      HL                  [$.D269]
        ld      DE                  [$.D261]
        and     A
        sbc     HL                  DE
        call    nz  :_315e
        ld      [$.D261]            DE
        
        ld      HL                  [$.D26B]
        ld      DE                  [$.D263]
        and     A
        sbc     HL                  DE
        call    nz  :_315e
        ld      [$.D263]            DE
        
        ld      HL                  [$.D26D]
        ld      DE                  [$D265]
        and     A
        sbc     HL                  DE
        call    nz  :_315e
        ld      [$D265]             DE
        
        ld      BC                  [$.D25F]
        ld      DE`sonicX           [$.SONIC.X]
        ld      HL`cameraX          [$.CAMERA_X]
        add     HL`cameraX          BC                  
        and     A
        sbc     HL`cameraX          DE`sonicX
        jr      c   ._4
        
        ld      A, H`cameraX
        and     A
        jr      nz  ._1
        
        ld      A                   L
        cp      $09
        jr      c   ._2
        
._1     ld      HL                  $0008
        
._2     bit     3   [IY`vars+#vars.scrollRingFlags]         ;auto scrolling right?
        jr      nz  ._
        
        ;is camera set to smooth scrolling?
        bit     5   [IY`vars+#vars.scrollRingFlags]
        jr      z   ._3                                     ;if not, skip ahead
        ld      HL                  $0001                   ;scroll only 1 pixel a time
        
        ;move camera X position
._3     ex      DE                  HL
        ld      HL                  [$.CAMERA_X]
        and     A
        sbc     HL                  DE
        jr      c   ._
        ld      [$.CAMERA_X]        HL
        jp      ._
        
._4     ld      BC                  [$.D261]
        ld      HL                  [$.CAMERA_X]
        add     HL                  BC
        and     A
        sbc     HL                  DE
        jr      nc  ._
        ld      A                   L
        cpl     
        ld      L                   A
        ld      A                   H
        cpl     
        ld      H                   A
        inc     HL
        ld      A                   H
        and     A
        jr      nz  ._5
        ld      A                   L
        cp      $09
        jr      c   ._6
._5     ld      HL                  $0008
._6     bit     3   [IY`vars+#vars.scrollRingFlags]         ;auto scroll right?
        jr      nz  ._
        bit     5   [IY`vars+#vars.scrollRingFlags]         ;smooth scrolling?
        jr      z   ._7
        ld      HL                  $0001
._7     ld      DE                  [$.CAMERA_X]
        add     HL                  DE
        jr      c   ._
        ld      [$.CAMERA_X]        HL
._      ld      HL                  [$.CAMERA_X]
        ld      DE                  [$.LEVEL_LEFT]
        and     A
        sbc     HL                  DE
        jr      nc  ._8
        ld      [$.CAMERA_X]        DE
        jr      ._9
        
._8     ld      HL                  [$.CAMERA_X]
        ld      DE                  [$.LEVEL_RIGHT]
        and     A
        sbc     HL                  DE
        jr      c   ._9
        ld      [$.CAMERA_X]        DE
        
._9     bit     6   [IY`vars+#vars.scrollRingFlags]         ;up-down wave scrolling?
        call    nz  :_3164
        
        ld      BC                  [$.D263]
        ld      DE                  [$.SONIC.Y+0]
        ld      HL                  [$.CAMERA_Y]
        
        bit     6   [IY`vars+#vars.scrollRingFlags]         ;up-down wave scrolling?
        call    nz  :_31cf
        
        bit     7   [IY`vars+#vars.scrollRingFlags]         ;no down scroll?
        call    nz  :_31d3
        
        add     HL                  BC
        bit     7   [IY`vars+#vars.scrollRingFlags]         ;no down scroll?
        call    z   :_31db
        and     A
        sbc     HL                  DE
        jr      c   ._13
        ld      C                   $09
        ld      A                   H
        and     A
        jr      nz  ._10
        
        bit     6   [IY`vars+#vars.scrollRingFlags]         ;up-down wave scrolling?
        call    nz  :_311f
        
        ld      A   L
        cp      C
        jr      c   ._11
        
._10    dec     C
        ld      L                   C
        ld      H                   $00
        
._11    bit     7   [IY`vars+#vars.scrollRingFlags]         ;no down scroll?
        jr      z   ._12
        
        srl     H
        rr      L
        bit     1   [IY`vars+#vars.unknown0]
        jr      nz  ._12
        
        ld      HL                  $0000
._12    ex      DE                  HL
        ld      HL                  [$.CAMERA_Y]
        and     A
        sbc     HL                  DE
        jr      c   ._16
        ld      [$.CAMERA_Y]        HL
        jp      ._16
        
._13    ld      BC                  [$D265]
        ld      HL                  [$.CAMERA_Y]
        add     HL                  BC
        bit     7   [IY`vars+#vars.scrollRingFlags]         ;no down scroll?
        call    z   :_31db
        and     A
        sbc     HL                  DE
        jr      nc  ._16
        ld      A                   L
        cpl     
        ld      L                   A
        ld      A                   H
        cpl     
        ld      H                   A
        inc     HL
        ld      C                   $09
        ld      A                   H
        and     A
        jr      nz  ._14
        
        bit     6   [IY`vars+#vars.scrollRingFlags]         ;up-down wave scrolling?
        call    nz  :_311f
        ld      A                   L
        cp      C
        jr      c   ._15
        
._14    dec     C
        ld      L                   C
        ld      H                   $00
        
._15    bit     4   [IY`vars+#vars.scrollRingFlags]         ;auto scroll up?
        jr      nz  ._16
        ld      DE                  [$.CAMERA_Y]
        add     HL                  DE
        jr      c   ._16
        
        ld      [$.CAMERA_Y]        HL
._16    ld      HL                  [$.CAMERA_Y]
        ld      DE                  [$.LEVEL_TOP]
        and     A
        sbc     HL                  DE
        jr      nc  ._17
        
        ld      [$.CAMERA_Y]        DE
._17    ld      HL                  [$.CAMERA_Y]
        ld      DE                  [$.LEVEL_BOTTOM]
        and     A
        sbc     HL                  DE
        jr      c   .ret
        ld      [$.CAMERA_Y]        DE
        
.ret    ret
}

PROC    :_311a                                              SECTION ::mobs                  ;$311A
        ;===========================================================================================
{        
        ld      [HL]                D
        dec     HL
        ld      [HL]                E
        inc     HL
        ret
}

PROC    :_311f                                              SECTION ::mobs                  ;$311F
        ;===========================================================================================
{
        ld      C                   $08
        ret
}

PROC    :scrollCameraTo_vertical                            SECTION ::mobs                  ;$3122
        ;===========================================================================================
        ;scroll vertically towards the locked camera position

PARAMS  HL
{
        ld      DE`ypos             [$.LEVEL_TOP]
        and     A
        sbc     HL                  DE`ypos
        ret     z
        jr      c   .up
        
        ;scroll downwards
        inc     DE`ypos
        ld      [$.LEVEL_TOP]       DE`ypos
        ld      [$.LEVEL_BOTTOM]    DE`ypos
        ret
        
        ;scroll upwards
.up     dec     DE`ypos
        ld      [$.LEVEL_TOP]       DE`ypos
        ld      [$.LEVEL_BOTTOM]    DE`ypos
        ret
}

PROC    :scrollCameraTo_horizontal                          SECTION ::mobs                  ;$3140
        ;===========================================================================================
        ;scroll horizontally towards the locked camera position
        
PARAMS  HL      ;$.RAM_CAMERA_X_GOTO
{
        ld      DE                  [$.LEVEL_LEFT]
        and     A                                           ;reset carry so it doesn't affect `sbc`
        sbc     HL                  DE
        ret     z                                           ;if HL = DE then return -- no change
        jr      c   ._1                                     ;is DE > HL?
        
        inc     DE
        ld      [$.LEVEL_LEFT]      DE
        ld      [$.LEVEL_RIGHT]     DE
        ret
        
._1     dec     DE
        ld      [$.LEVEL_LEFT]      DE
        ld      [$.LEVEL_RIGHT]     DE
        ret
}

PROC    :_315e                                              SECTION ::mobs                  ;$315E
        ;===========================================================================================
{
        jr      c   ._1
        inc     DE
        ret
        
._1     dec     DE
        ret
}

PROC    :_3164                                              SECTION ::mobs                  ;$3164
        ;===========================================================================================
{
        ld      HL                  [$.D29D]
        ld      DE                  [$.TIME]
        add     HL                  DE
        ld      BC                  $0200
        ld      A                   H
        and     A
        jp      p   ._1
        neg     
        ld      BC                  $FE00
._1     cp      $02
        jr      c   ._2
        ld      L                   C
        ld      H                   B
._2     ld      [$.D29D]            HL
        ld      C                   L
        ld      B                   H
        ld      HL                  [$.D25C]                ;between RAM_CAMERA_X & Y
        ld      A                   [$.CAMERA_Y+1]          ;high-byte of RAM_CAMERA_X
        add     HL                  BC
        ld      E                   $00
        bit     7   B
        jr      z   ._3
        ld      E                   $FF
._3     adc     A                   E
        ld      [$.D25C]            HL
        ld      [$.CAMERA_Y+1]      A
        ld      HL                  [$.D2A1]
        ld      A                   [$.D2A3]
        add     HL                  BC
        adc     A                   E
        ld      [$.D2A1]            HL
        ld      [$.D2A3]            A
        ld      HL                  [$.D2A2]
        bit     7   H
        jr      z   ._4
        ld      BC                  $FFE0
        and     A
        sbc     HL                  BC
        jr      nc  ._4
        ld      HL                  $0002
        ld      [$.TIME]            HL
        ret
        
._4     ld      HL                  [$.D2A2]
        ld      BC                  $0020
        and     A
        sbc     HL                  BC
        ret     c
        ld      HL                  $FFFE
        ld      [$.TIME]            HL
        ret
}

PROC    :_31cf                                              SECTION ::mobs                  ;$31CF
        ;===========================================================================================
{
        ld      BC                  $0020
        ret
}

PROC    :_31d3                                              SECTION ::mobs                  ;$31D3
        ;===========================================================================================
{
        ld      BC                  $0070
        ret
}

PROC    :unused_31d7                                        SECTION ::mobs                  ;$31D7
        ;===========================================================================================
{
        ld      BC                  $0070
        ret
}

PROC    :_31db                                              SECTION ::mobs                  ;$31DB
        ;===========================================================================================
PARAMS  IY`vars         ``Address of the common variables (used throughout)
        HL
{       ;not applicable with up-down wave scrolling
        bit     6   [IY`vars+#vars.scrollRingFlags]
        ret     nz
        
        ld      BC                  [$.D2B7]
        add     HL                  BC
        
        ret
}

PROC    :checkMobsOutOfBounds                               SECTION ::mobs                  ;$31E6
        ;===========================================================================================
HELP ```Check active mobs to see if they have moved too far off-screen and need to be despawned.
        To avoid slow down only four mobs are checked per frame
        ```
{       ;check only 4 mobs per frame:
        ;-------------------------------------------------------------------------------------------
        
        ld      A`frame             [$.FRAMECOUNT]
        and     %00000111                                   ;"MOD 8"
        ;TODO: a look-up table for this multiplication should be faster
        ld      C`multiply          A`frame
        ld      HL`fourMobs         $0068                   ;=104 (size of 4 mob structures)
        call    ::main:multiply                             ;multiply 104 by the frame number 0-7
        
        ld      DE`mobAddr          $.SONIC                 ;address of first mob's data
        add     HL`fourMobs         DE`mobAddr              ;offset to the chosen group of 4 mobs
        ex      DE`mobAddr          HL`fourMobs             ;put this aside for now
        
        ;; skips through the list of current mobs 4 at a time
           i.e. mob number 0, 4, 8, 12, 16, 20, 24, 28 ;;
        
        ;; TODO: Could transfer the "A MOD 8" result via register I
                 to avoid having to redo this calculation ;;
        ld      A`frame             [$.FRAMECOUNT]
        and     %00000111                                   ;"MOD 8"
        add     A`mobIndex          A`mobIndex              ;x 2
        add     A`mobIndex          A`mobIndex              ;x 4
        add     A`mobIndex          A`mobIndex              ;x 8
        ld      C`mobOffset         A`mobIndex
        ld      B`mobOffset         $00
        ld      HL`mobPointer       $.ACTIVEMOBS            ;list of current mob pointers
        add     HL`mobPointer       BC`mobOffset
        
        ld      C`zero              B`zero                  ;this will be used to remove mobs
        ld      B`counter           4                       ;load loop counter for 4 mobs
        
        ;fetch the mob's boundary data:
        ;-------------------------------------------------------------------------------------------
        
.loop   ld      A`mobID             [DE`mobAddr]            ;get the mob ID (which type it is)
        cp      $56                                         ;> length of the mob code pointers list?
        jp      nc  .removeMob                              ;skip this loop
        
        ;switch the mob address to IX
        push    DE`mobAddr
        pop     IX`mobAddr
        
        ;swap BC/DE/HL with their shadow values
        exx
        
        ;TODO: perhaps a lookup table could be faster here
        add     A`dataOffset        A`mobID                 ;double the mob ID
        ld      L'dataOffset        A`dataOffset            ;put this into HL'
        ld      H'dataOffset        $00
        add     HL'dataOffset       HL'dataOffset           ;ID x 4
        add     HL'dataOffset       HL'dataOffset           ;ID x 8, i.e. 8 bytes per ID
        
        ld      DE'dataTable        :mobBounds
        add     HL'dataOffset       DE'dataTable            ;offset into the table, 8 bytes per ID
        
        ;; load BC with the first WORD, the maxmimum distance left of the camera
           the mob can go before despawning ;;
        ld      C'leftLimit         [HL'data]
        inc     HL'data
        ld      B'leftLimit         [HL'data]
        
        ;copy the remaining data into the temporary space
        inc     HL'data
        ld      DE'temp             $.TEMP1
        ;; BUG: this reduces BC' by 6, likely unintended as the leftLimit value
           does not already factor this in and does not benefit from it ;;
        ldi
        ldi
        ldi     
        ldi     
        ldi     
        ldi
        
        ;left & right bounds:
        ;-------------------------------------------------------------------------------------------
        
        ;; if the camera is near the left edge of the Floor Layout then the mob's area of
           off-screen allowance will overhang void-space. we check for this to avoid miscalculation
           further down the line ;;
        ld      HL'cameraX          [$.CAMERA_X]
        xor     A`zero                                      ;reset carry flag
        sbc     HL'cameraX          BC'leftLimit     
        jr      nc  .x
        
        ;; the camera is at the left-most side of the floor, 
           so don't underflow and believe the camera is at the far-right instead ;;
        ld      L'cameraX           A`zero
        ld      H'cameraX           A`zero
        xor     A`zero
        
        ;has the mob gone too far left of the camera?
.x      ld      E'mobXpos           [IX+#mob.X+0]
        ld      D'mobXpos           [IX+#mob.X+1]
        sbc     HL'leftLimit        DE'mobXpos
        jp      nc  .removeMobExx                           ;if so, remove it
        
        ;; the next WORD is how far right of the camera the mob can go before despawning.
           note that this value has the width of the screen included ;;
        ;TODO: would adding 256 to the left limit be faster / good enough?
        ld      HL'rightLimit       [$.TEMP1]
        ld      BC'cameraX          [$.CAMERA_X]
        add     HL'rightLimit       BC'cameraX
        xor     A`zero                                      ;reset carry flag
        sbc     HL'rightLimit       DE'mobXpos              ;has the mob gone too far right?
        jp      c   .removeMobExx                           ;if so, remove it
        
        ;top & bottom bounds:
        ;-------------------------------------------------------------------------------------------
        
        ;; if the camera is near the top edge of the Floor Layout then the mob's area of off-screen
           allowance will overhang void-space. we check for this to avoid miscalculation further
           down the line ;;
        ld      HL'cameraY          [$.CAMERA_Y]
        ld      BC'topLimit         [$.TEMP3]
        sbc     HL'cameraY          BC'
        jr      nc  .y 
        
        ;; the camera is at the top-most side of the floor, 
           so don't underflow and believe the camera is at the bottom instead ;;
        ld      L'cameraY           A`zero
        ld      H'cameraY           A`zero
        xor     A`zero
        
.y      ;has the mob gone too far above the camera?
        ld      E'mobYpos           [IX+#mob.Y+0]
        ld      D'mobYpos           [IX+#mob.Y+1]
        sbc     HL'                 DE'mobYpos
        jp      nc  .removeMobExx                           ;if so, remove it
        
        ;; the next WORD is how far below the camera the mob can go before despawning.
           note that this value has the height of the screen included ;;
        ;; TODO: would adding 192 to the bottom limit be faster / good enough?
                 also this would help with dynamically supporting 224-lines ;;
        ld      HL'bottomLimit      [$.TEMP4]
        ld      BC'cameraY          [$.CAMERA_Y]
        add     HL'bottomLimit      BC'cameraY
        xor     A`zero
        sbc     HL'bottomLimit      DE'mobYpos
        jp      c   .removeMobExx
        
        ;-------------------------------------------------------------------------------------------
        
        ;return to the non-shadow BC/DE/HL values
        exx
        
        ;TODO: why do we need to write the same pointer back again?
        ld      [HL`mobPointer]     E`mobAddr
        inc     HL`mobPointer
        ld      [HL`mobPointer]     D`mobAddr
        inc     HL`mobPointer
        
        ;move on to the next mob to process
        push    HL`mobPointer
        ld      HL`dataSize         $001A                   ;=26, size of a mob structure
        add     HL`dataSize         DE`mobAddr
        ex      DE`dataSize         HL`mobAddr
        pop     HL`mobPointer
        
        djnz    .loop
        
        ret
        
        ;remove the out-of-bounds mob!
        ;-------------------------------------------------------------------------------------------
        
.removeMobExx
        ;return to the non-shadow BC/DE/HL values
        exx
        
.removeMob
        ;zero out the pointer to the mob in the active mob list
        ld      [HL`mobPointer]     C`zero
        inc     HL`mobPointer
        ld      [HL`mobPointer]     C`zero
        inc     HL`mobPointer
        
        ;move on to the next mob to process
        push    HL`mobPointer
        ld      HL`dataSize         $001A                   ;=26, size of a mob structure
        add     HL`dataSize         DE`mobAddr
        ex      DE`dataSize         HL`mobAddr
        pop     HL`mobPointer
        
        ;; TODO: djnz cannot be used here probably because of >-128 relative jump.
                 reorganisation of code might solve this ;;
        dec     B`coutner
        jp      nz  .loop
        
        ret
}

PROC    :doMobs                                             SECTION ::mobs                  ;$392B
        ;===========================================================================================
        ;runs the code for each of the mobs in memory
        
PARAMS  IY`vars         ``Address of the common variables (used throughout)
{        
        ;; starting from $D37E (we skip Sonic), read pointers until a non-zero one is found,
           or 31 pointers have been read ;;
        ld      HL                  $.ACTIVEMOBS+2
        ld      B                   31
        
        ;read the pointer into DE
.loop   ld      E                   [HL]
        inc     HL
        ld      D                   [HL]
        inc     HL
        
        ;is the pointer non-zero?
        ld      A                   E
        or      D
        call    nz  :doMob                                  ;if so process as a mob
        
        ;keep reading memory until either something non-zero is found or we hit $D3BC
        djnz    .loop
        
        ;-------------------------------------------------------------------------------------------
        
        ld      A                   [IY`vars+#vars.spriteUpdateCount]
        ld      HL                  [$.SPRITETABLE_ADDR]
        
        push    AF
        push    HL
        
        ;process the player:
        ld      HL                  $D024                   ;Sonic's sprite table entry
        ld      [$.SPRITETABLE_ADDR]    HL
        ld      DE                  $.SONIC
        call    :doMob
        
        pop     HL  AF
        
        ld      [$.SPRITETABLE_ADDR]    HL
        ld      [IY`vars+#vars.spriteUpdateCount]   A
        ret
}

PROC    :doMob                                              SECTION ::mobs                  ;$32C8
        ;-------------------------------------------------------------------------------------------
PARAMS  DE              ``Address of a mob structure
{       
        ld      A                   [DE]                    ;get mob from the list
        cp      $FF                                         ;ignore mob type $FF
        ret     z
        
        push    BC  HL
        
        ;transfer DE (address of the mob) to IX
        push    DE
        pop     IX
        
        ;double the mob type number and put it into DE
        add     A                   A
        ld      E                   A
        ld      D                   $00
        
        ;offset into the mob code pointers table
        ld      HL                  :mobPointers
        add     HL                  DE
        
        ;get the mob's code address into HL
        ld      A                   [HL]
        inc     HL
        ld      H                   [HL]
        ld      L                   A
        
        ;; once the mob's own code has been run,
           handle the common actions for all mobs ;;
        ld      DE                  :doMobCommon
        push    DE
        
        ;run the mob's code
        jp      [HL]
}
        
PROC    :doMobCommon                                        SECTION ::mobs                   ;$32E2
        ;-------------------------------------------------------------------------------------------
HELP ```Once a mob has run its personal code, this routine handles things that all mobs share,
        such as moving the mob, and collision with Sonic
        ```
PARAMS  IX`mob          ``Address of the current mob being processed
{       
        ;move mob:
        ;-------------------------------------------------------------------------------------------
        
        ;TODO: could have a mob flag to mark as stationary and skip this bit
        
        ;move the mob horizontally 
        ld      E`speed             [IX`mob+#mob.Xspeed+0]
        ld      D`speed             [IX`mob+#mob.Xspeed+1]
        ld      C`dir               [IX`mob+#mob.Xdirection]
        
        ld      L`xpos              [IX`mob+#mob.Xsubpixel]
        ld      H`xpos              [IX`mob+#mob.X+0]
        ld      A`xpos              [IX`mob+#mob.X+1]
        add     HL`xpos             DE`speed
        adc     A`xpos              C`dir
        
        ld      [IX`mob+#mob.Xsubpixel] L`xpos
        ld      [IX`mob+#mob.X+0]       H`xpos
        ld      [IX`mob+#mob.X+1]       A`xpos
        
        ;move the mob vertically
        ld      E`speed             [IX`mob+#mob.Yspeed+0]
        ld      D`speed             [IX`mob+#mob.Yspeed+1]
        ld      C`dir               [IX`mob+#mob.Ydirection]
        ld      L`ypos              [IX`mob+#mob.Ysubpixel]
        ld      H`ypos              [IX`mob+#mob.Y+0]
        ld      A`ypos              [IX`mob+#mob.Y+1]
        add     HL`ypos             DE`speed
        adc     A`ypos              C`dir
        
        ld      [IX`mob+#mob.Ysubpixel] L`ypos
        ld      [IX`mob+#mob.Y+0]       H`ypos
        ld      [IX`mob+#mob.Y+1]       A`ypos
        
        ;check for mob collision with floor:
        ;-------------------------------------------------------------------------------------------
        
        ;does the mob interact with the floor?
        bit     5   [IX`mob+#mob.flags]
        jp      nz  ._34e6                                  ;if not skip over collision handling
        
        ;divide the mob height by 2 to find its vertical middle point
        ld      B`zero              $00
        ld      D`yOffset           B`zero
        ld      E`yOffset           [IX+#mob.height]
        srl     E`yOffset                                   ;divide height by 2
        
        ;facing left or right?
        bit     7   [IX`mob+#mob.Xspeed+1]
        jr      nz  .facingLeft
        
        ;facing right:
        ; - collision will be checked with the right side of the mob
        ld      C`xOffset           [IX`mob+#mob.width]
        ld      HL`table            :Unknown._411E
        jp      ._2
        
.facingLeft
        ;facing left:
        ; - collision will be checked with the left side of the mob
        ld      C`xOffset           $00                     ;TODO: B & D are zero, could use those
        ld      HL`table            :Unknown._4020
        
        ;put aside the 'nose' x-position of the mob
._2     ld      [$.TEMP3]           BC`xOffset
        res     6   [IX`mob+#mob.flags]
        
        push    DE`yOffset
                HL`table
        
        ;lookup the block underneath the mob
        call    :getFloorLayoutRAMAddressForMob
        ld      E`block             [HL`floorLayout]
        ld      D`block             $00
        ;TODO: all this solidity pointer lookup could be done away with by storing this result
        ;      in RAM somewhere (or in the level header)
        ld      A`solidityID        [$.LEVEL_SOLIDITY]      ;solidity index for the level
        add     A`solidityID        A`solidityID            ;double it for a table look-up
        ld      C`index             A`solidityID            ;transfer value to BC
        ld      B`index             D`zero
        ;offset into the solidity table
        ld      HL`table            :S1_Solidity_Blocks 
        add     HL`table            BC`index
        ;get the level's solidity pointer from the table
        ld      A`pointer           [HL`table]
        inc     HL`table
        ld      H`pointer           [HL`table]
        ld      L`pointer           A`pointer
        ;look up the block in the level's block solidity table
        add     HL`pointer          DE`block
        ld      A`blockSolidity     [HL`pointer]
        
        and     %00111111                                   ;exclude water flag in solidity?
        ld      [$.TEMP6]           A`solidity
        
        pop     HL`table
                DE`yOffset
        
        and     %00111111                                   ;air (or water), and nothing else?
        jp      z   ._7
        
        ;TODO: could we not have used B/C instead of [$.TEMP6] here?
        ld      A`solidity          [$.TEMP6]
        add     A`solidity          A`solidity              ;double it for a look-up table
        ld      C`index             A`solidity              ;transfer to BC
        ld      B`index             $00
        
        ;TODO: this might not be necessary, D could already be 0?
        ld      D`yOffset           B`zero
        
        ;offset into the lookup table, either ":Unknown._411e" (facing right)
         ;or ":Unknown._4020" (facing left)
        add     HL`table            BC`index
        ld      A`pointer           [HL`table]
        inc     HL`table    
        ld      H`pointer           [HL`table]
        ld      L`pointer           A`pointer
        
        ;the data is a per-line solidity lookup!
        ld      A`yPos              [IX`mob+#mob.Y+0]
        add     A`yPos              E`yOffset               ;get the vertical middle point
        and     $1F                                         ;"MOD 32"
        ld      E`yPos              A`yPos
        add     HL`pointer          DE`yPos
        
        ;skip "air"?
        ld      A`lineSolidity      [HL`table]
        cp      $80
        jp      z   ._7
        
        ld      E`lineSolidity      A`lineSolidity
        and     A`lineSolidity
        jp      p   ._3                                     ;skip if bit 7 is unset
        
        ld      D                   $FF
._3     ld      L`xPos              [IX`mob+#mob.X+0]
        ld      H`xPos              [IX`mob+#mob.X+1]
        ;retrieve the 'nose' position of the mob
        ld      BC`xOffset          [$.TEMP3]
        add     HL`xPos             BC`xOffset
        
        ;facing left or right?
        bit     7   [IX`mob+#mob.Xdirection]
        jr      nz  ._4
        
        ;facing left:
        and     A`lineSolidity
        jp      m   ._5                                     ;skip if bit 7 is set
        
        ld      A`xPos              L`xPos
        and     $1F                                         ;"MOD 32"
        cp      E`lineSolidity
        jr      nc  ._5
        
        jp      ._7
        
        ;facing right:
._4     and     A`lineSolidity
        jp      m   ._5                                     ;skip if bit 7 is set
        
        ld      A`xPos              L`xPos
        and     $1F                                         ;"MOD 32"
        cp      E`lineSolidity
        jr      nc  ._7
        
        ;collision:
        ;...........................................................................................
        
._5     set     6   [IX`mob+#mob.flags]
        
        ;; clip xPos to whole counts of 32 -- convert xPos to the left-nearest block
           (effectively "INT(xPos / 32) * 32") ;;
        ld      A`xPos              L`xPos
        and     %11100000
        
        ld      L`xPos              A`xPos
        add     HL`xPos             DE`lineSolidity
        and     A`flags                                     ;clear carry flag
        sbc     HL`xPos             BC`xOffset
        ld      [IX`mob+#mob.X+0]   L`xPos
        ld      [IX`mob+#mob.X+1]   H`xPos
        
        ld      A`solidity          [$.TEMP6]
        ld      E`solidity          A`solidity
        ld      D`zero              $00
        ld      HL                  :UnknownCollision._3FBF ;data?
        add     HL                  DE
        ld      C                   [HL]
        
        ld      [IX`mob+#mob.Xspeed+0]      D`zero
        ld      [IX`mob+#mob.Xspeed+1]      D`zero
        ld      [IX`mob+#mob.Xdirection]    D`zero
        ld      A                   D`zero
        ld      B                   D`zero
        
        bit     7   C
        jr      z   ._6
        
        ;unused because of the data!?
        dec     A
        dec     B
        
._6     ld      L                   [IX`mob+#mob.Yspeed+0]
        ld      H                   [IX`mob+#mob.Yspeed+1]
        add     HL                  BC
        adc     A                   [IX`mob+#mob.Ydirection]
        ld      [IX`mob+#mob.Yspeed+0]      L
        ld      [IX`mob+#mob.Yspeed+1]      H
        ld      [IX`mob+#mob.Ydirection]    A
        
        ;no collision?
        ;...........................................................................................
        
        ;zero the upper bytes of two sixteen bit words
._7     ld      B`zero              $00
        ld      D`zero              B`zero
        
        bit     7   [IX`mob+#mob.Yspeed+1]
        jr      nz  ._8
        
        ld      C                   [IX`mob+#mob.width]
        srl     C
        ld      E                   [IX`mob+#mob.height]
        ld      HL                  :Unknown._448A
        jp      ._9
        
._8     ld      C                   [IX`mob+#mob.width]
        srl     C
        ld      E                   $00
        ld      HL                  :Unknown._41EC
._9     ld      [$.TEMP3]           DE
        res     7   [IX`mob+#mob.flags]
        push    BC
        push    HL
        call    :getFloorLayoutRAMAddressForMob
        ld      E                   [HL]
        ld      D                   $00
        ld      A                   [$.LEVEL_SOLIDITY]
        add     A                   A
        ld      C                   A
        ld      B                   D
        ld      HL                  :S1_Solidity_Blocks
        add     HL                  BC
        ld      A                   [HL]
        inc     HL
        ld      H                   [HL]
        ld      L                   A
        add     HL                  DE
        ld      A                   [HL]
        and     $3F
        ld      [$.TEMP6]           A
        pop     HL
        pop     BC
        and     $3F
        jp      z   ._34e6
        ld      A                   [$.TEMP6]
        add     A                   A
        ld      E                   A
        ld      D                   $00
        ld      B                   D
        add     HL                  DE
        ld      A                   [HL]
        inc     HL
        ld      H                   [HL]
        ld      L                   A
        ld      A                   [IX`mob+#mob.X+0]
        add     A                   C
        and     $1F
        ld      C                   A
        add     HL                  BC
        ld      A                   [HL]
        cp      $80
        jp      z   ._34e6
        ld      C                   A
        and     A
        jp      p   ._10
        ld      B                   $FF
._10    ld      L                   [IX`mob+#mob.Y+0]
        ld      H                   [IX`mob+#mob.Y+1]
        ld      DE                  [$.TEMP3]
        add     HL                  DE
        bit     7   [IX`mob+#mob.Ydirection]
        jr      nz  ._11
        and     A
        jp      m   ._12                                    ;skip if bit 7 is set
        ld      A                   L
        and     $1F
        exx     
        ld      HL                  [$.TEMP6]
        ld      H                   $00
        ld      DE                  :UnknownCollision._3FF0
        add     HL                  DE
        add     A                   [HL]
        exx     
        cp      C
        jr      c   ._34e6
        set     7   [IX`mob+#mob.flags]
        jp      ._12
        
._11    and     A
        jp      m   ._12                                    ;skip if bit 7 is set
        ld      A                   L
        and     $1F
        exx     
        ld      HL                  [$.TEMP6]
        ld      H                   $00
        ld      DE                  :UnknownCollision._3FF0
        add     HL                  DE
        add     A                   [HL]
        exx     
        cp      C
        jr      nc  ._34e6
._12    ld      A                   L
        and     $E0
        ld      L                   A
        add     HL                  BC
        and     A
        sbc     HL                  DE
        ld      [IX`mob+#mob.Y+0]   L
        ld      [IX`mob+#mob.Y+1]   H
        ld      A                   [$.TEMP6]
        ld      E                   A
        ld      D                   $00
        ld      HL                  $3F90                        ;data?
        add     HL                  DE
        ld      C                   [HL]
        ld      [IX`mob+#mob.Yspeed+0]      D
        ld      [IX`mob+#mob.Yspeed+1]      D
        ld      [IX`mob+#mob.Ydirection]    D
        ld      A                   D
        ld      B                   D
        bit     7   C
        jr      z   ._13
        dec     A
        dec     B
._13    ld      L                   [IX`mob+#mob.Xspeed+0]
        ld      H                   [IX`mob+#mob.Xspeed+1]
        add     HL                  BC
        adc     A                   [IX`mob+#mob.Xdirection]
        ld      [IX`mob+#mob.Xspeed+0]      L
        ld      [IX`mob+#mob.Xspeed+1]      H
        ld      [IX`mob+#mob.Xdirection]    A
        
        ;is the mob on-screen?
        ;-------------------------------------------------------------------------------------------

._34e6  ld      L`yPos              [IX`mob+#mob.Y+0]
        ld      H`yPos              [IX`mob+#mob.Y+1]
        ld      BC`cameraY          [$.CAMERA_Y]
        and     A`flags                                     ;reset flags
        sbc     HL`yPos             BC`cameraY
        ex      DE                  HL
        
        ld      L`xPos              [IX+#mob.X+0]
        ld      H`xpos              [IX+#mob.X+1]
        ld      BC`cameraX          [$.CAMERA_X]
        and     A`flags                                     ;reset flags
        sbc     HL                  BC
        
        ld      C                   [IX`mob+#mob.spriteLayout+0]
        ld      B                   [IX`mob+#mob.spriteLayout+1]
        ld      A                   C
        or      B
        call    nz  :processSpriteLayout
        
        pop     HL
                BC
        
        ret
}

PROC    :processSpriteLayout                                SECTION ::mobs                  ;$350F
        ;===========================================================================================
HELP ```Puts a mob on the screen, combining multiple sprites using a Sprite Layout -
        a list of sprites to arrange in a maximum 6x4 layout
        ```
PARAMS  IY`vars         ``Address of the common variables (used throughout)
        HL`xPos         ``X-position to place sprite layout on screen
        D               ;?? (some kind of control flag)
        E`ypos          ``Y-position to place sprite layout on screen
        BC`layoutDat    ``Address of a sprite layout
{
        ;store the X-position of the sprite for aligning the rows
        ld      [$.TEMP6]           HL`xpos
        
        ;copy BC (address of a sprite layout) to its shadow value BC'
        push    BC`layoutData
        exx
        pop     BC'layoutData
        exx
        
        ;rows:
        ;-------------------------------------------------------------------------------------------
        ;there will be 3 rows of double-high (16px) sprites
        ld      B`rows              0
        ld      C`rows              3
        
._1     exx                                                 ;switch to BC/DE/HL shadow values
        
        ld      HL'xpos             [$.TEMP6]               ;get the starting X-position
                                                            ;(original HL parameter)
        
        ;; if a row begins with $FF, the data ends early
           begin a row with $FE to provide a space without ending the data early ;;
        
        ld      A                   [BC'layoutData]         ;get a byte from the sprite layout data
        
        exx                                                 ;switch to original BC/DE/HL values
        
        cp      $FF                                         ;is the byte $FF?
        ret     z                                           ;if so leave
        
        ;DE is the Y-position, but if D is $FF then something else unknown happens
        
        ld      A                   D                       ;check the D parameter
        cp      $FF                                         ;if D is not $FF
        jr      nz  ._2                                     ;then skip ahead a little
        
        ld      A                   E                       ;check the E parameter
        cp      $F0                                         ;if it's less than $F0,
        jr      c   ._5                                     ;then skip ahead
        jp      ._3
        
._2     and     A                                           ;is the sprite byte 0?
        jr      nz  ._5
        
        ;exit if the row Y-position is below the screen
        ld      A                   E
        cp      192
        ret     nc
        
        ;columns:
        ;-------------------------------------------------------------------------------------------
._3     ;begin 6 columns of single-width (8px) sprites
        ld      B                   $06
        
.loop   exx                                                 ;switch to BC/DE/HL shadow values
        
        ;has the X-position gone over 255?
        ld      A                   H'                      ;check the H parameter
        and     A                                           ;is it >0? i.e. HL = $0100
        jr      nz  ._4                                     ;if so skip
        
        ld      A                   [BC']                   ;check the current byte of the layout data
        cp      $FE                                         ;is it >= than $FE?
        jr      nc  ._4                                     ;if so, skip
        
        ;get the address of the sprite table entry
        ld      DE'                 [$.SPRITETABLE_ADDR]        
        ld      A                   L'                      ;take the current X-position
        ld      [DE']               A                       ;and set the sprite's X-position
        inc     E'                               
        exx
        ld      A                   E                       ;get the current Y-position
        exx
        ld      [DE']               A                       ;set the sprite's Y-position 
        inc     E'
        ld      A                   [BC']                   ;read the layout byte
        ld      [DE']               A                       ;set the sprite index number
        
        ;move to the next sprite table entry
        inc     E'
        ld      [$.SPRITETABLE_ADDR]    DE'        
        inc     [IY`vars+#vars.spriteUpdateCount]
        
        ;move across 8 pixels
._4     inc     BC'
        ld      DE'                     $0008
        add     HL'                     DE'
        
        ;return B to the column count and decrement
        exx
        djnz    .loop
        
        ;move down 16-pixels
        ld      A                       C
        ex      DE                      HL
        ld      C                       16
        add     HL                      BC
        ex      DE                      HL
        
        ;any rows remaining?
        ld      C                       A
        dec     C
        jr      nz  ._1
        ret
        
        ;-------------------------------------------------------------------------------------------
        ;TODO: need to work this out (when D is $FF)
._5     exx
        ex      DE                      HL
        ld      hl, $0006
        add     hl, bc
        ld      c, l
        ld      b, h
        ex      de, hl
        exx
        ld      a, c
        ex      de, hl
        ld      c, $10
        add     hl, bc
        ex      de, hl
        ld      c, a
        dec     c
        jr      nz, ._1
        
        ret
}

PROC    :_3581                                  SECTION ::mobs                  ;$3581
        ;===============================================================================
PARAMS  IY`vars         ``Address of the common variables (used throughout)
        $.TEMP3
        $.TEMP6
        $.TEMP1
        $.TEMP4
{        
        ld      hl,[$.TEMP3]
        ld      bc,[$.TEMP6]
        add     hl,bc
        ld      bc,[$.CAMERA_Y]
        and     a
        sbc     hl,bc
        ex      de,hl
        ld      hl,[$.TEMP1]
        ld      bc,[$.TEMP4]
        add     hl,bc
        ld      bc,[$.CAMERA_X]
        and     a
        sbc     hl,bc
        ld      c,a
        ld      a,h
        and     a
        ret     nz
        ld      a,d
        cp      $ff
        jr      nz,._1
        ld      a,e
        cp      $f0
        ret     c
        jp      ._2
        
._1     and     a
        ret     nz
        ld      a,e
        cp      $c0
        ret     nc
._2     ld      h,c
        ld      bc,[$.SPRITETABLE_ADDR]
        ld      a,l
        ld      [bc],a
        inc     c
        ld      a,e
        ld      [bc],a
        inc     c
        ld      a,h
        ld      [bc],a
        inc     c
        ld      [$.SPRITETABLE_ADDR],bc
        inc     [iy+#vars.spriteUpdateCount]
        ret
}

PROC    :layoutSpritesHorizontal                SECTION ::mobs                  ;$35CC
        ;===============================================================================
HELP ```Places a set of sprites next to each other, dictated by a small data stream of
        indexes, with $FE to leave a blank space and $FF to terminate. This routine is
        typically used to place text and numbers on screen.
        ```
PARAMS  IY`vars         ``Address of the common variables (used throughout)
        B`ypos
        C`xpos
        HL`addr         ;($.SPRITETABLE_ADDR)  
        DE`data         ;$.LAYOUT_BUFFER        : $A0, $A2, $A4, ($80 + $.LIVES * 2), $FF
{       
        ld      A`tileIndex, [DE`data]          ;check the current byte in the list
        cp      $FF                             ;is it an end marker? ($FF)
        ret     z                               ;if so, return
        
        cp      $FE                             ;special case for $FE command
        jr      z, .skip                        ;(skip ahead)
        
        ld      [HL`addr], C`xpos
        inc     L`addr
        ld      [HL`addr], B`ypos
        inc     L`addr
        ld      [HL`addr], A`tileIndex
        inc     L`addr
        
        inc     [IY+#vars.spriteUpdateCount]
        
.skip   inc     DE`data                         ;move to the next data byte
        ;move right 8 pixels
        ld      A`xpos, C`xpos
        add     A`xpos, 8                       
        ld      C`xpos, A`xpos
        jp      :                               ;process more sprites in the list
}

PROC    :hitPlayer                              SECTION ::mobs                  ;$35E5
        ;===============================================================================
PARAMS  IY`vars         ``Address of the common variables (used throughout)
{
        bit     0,[IY+#vars.scrollRingFlags]    ;is the player already dead?
        ret     nz                              ;if so, leave now
        
        bit     0,[IY+#vars.unknown0]
        jp      nz,:_36be
        
        ld      A,[$.SONIC.flags]
        rrca    
        jp      c,:_36be
        
        and     %00000010
        jp      nz,:_36be
        
        ;-------------------------------------------------------------------------------
._35fd                                                                          ;$35FD
        bit     0,[IY+#vars.flags9]
        ret     nz
        
        bit     6,[IY+#vars.flags6]             ;is player in damage-state?
        ret     nz                              ;if so, do not continue
        
        bit     0,[IY+#vars.unknown0]
        ret     nz
        
        bit     5,[IY+#vars.flags6]
        jr      nz,:dropRings._367e
        
        ;has the player any rings?
        ld      A`rings         [$.RINGS]
        and     A`rings
        jr      nz,:dropRings                       ;if so, drop them
        
        ;-------------------------------------------------------------------------------
.kill   ;kill the player!                                                       ;$3618
        set     0,[IY+#vars.scrollRingFlags]
        
        ;set flag 7 on the mob (mob death state?)
        ld      HL              $.SONIC.flags
        set     7               [HL]
        
        ld      HL              $FFFA
        xor     A`zero                          ;set A to zero
        ld      [$.SONIC.Yspeed+0]             A`zero
        ld      [$.SONIC.Yspeed+1]             HL
        
        ld      A,$60
        ld      [$.D287],A
        
        res     6,[IY+#vars.flags6]             ;turn off damage-state flag
        res     5,[IY+#vars.flags6]             ;remove shield
        res     6,[IY+#vars.flags6]             ;TODO: bug or oversight?
        res     0,[IY+#vars.unknown0]           ;the 0 byte from the level header
        
        ;play the death sound effect
        ld      A`sfx           ::sound:S1_MusicPointers.death.index
        rst     :rst_playMusic
        
        ret
}

PROC    :dropRings                              SECTION ::mobs                  ;$3644
        ;-------------------------------------------------------------------------------
        ;lose rings!
        
PARAMS  IX`mob          ``Address of the current mob being processed
        IY`vars         ``Address of the common variables (used throughout)
        HL              ;?
{       
        ;set player's ring-count to 0
        xor     A`zero
        ld      [$.RINGS]       A`zero
        
        ;find an available unused mob-slot
        call    :findEmptyMob
        jr      c,._367e
        
        push    IX, HL
        pop     IX
        
        ld      [IX+#mob.type],$55              ;"make Sonic blink"?
        ld      [IX+#mob.unknown11],$06
        ld      [IX+$12],$00
        ld      HL,[$.SONIC.X]
        ld      [IX+#mob.X+0],L
        ld      [IX+#mob.X+1],H
        ld      HL,[$.SONIC.Y]
        ld      [IX+#mob.Y+0],L
        ld      [IX+#mob.Y+1],H
        ld      [IX+#mob.Yspeed+0],$00
        ld      [IX+#mob.Yspeed+1],$fc
        ld      [IX+#mob.Ydirection],$ff
        pop     IX
        
._367e  ld      HL,$.SONIC.flags
        ld      DE,$fffc
        xor     A`zero
        
        bit     4,[HL]
        jr      z,._1
        
        ld      DE,$fffe
._1     ld      [$.SONIC.Yspeed+0],A
        ld      [$.SONIC.Yspeed+1],DE
        bit     1,[HL]
        jr      z,._2
        ld      A,[HL]
        or      $12
        ld      [HL],A
        xor     A`zero
        ld      DE,$0002
        jr      ._3
        
._2     res     1,[hl]
        xor     a`zero
        ld      de,$fffe
._3     ld      [$.SONIC.Xspeed+0],a
        ld      [$.SONIC.Xspeed+1],de
        res     5,[iy+#vars.flags6]
        set     6,[iy+#vars.flags6]
        ld      [iy+#vars.joypad],$ff
        
        ld      A,$11
        rst     :rst_playSFX
        
        ret
}

PROC    :_36be                                  SECTION ::mobs                  ;$36BE
        ;-------------------------------------------------------------------------------
PARAMS  IX`mob          ``Address of the current mob being processed
        ;TODO: we could use BC/DE as parameters instead of RAM addresses?
        $.TEMP1         ``An X-offset to place the explosion in the right place
        $.TEMP2         ``A Y-offset to place the explosion in the right place
{        
        ld      [IX+#mob.type]  $0A             ;change mob to explosion
        
        ;get the X-offset given in the parameter
        ld      A`x_offset      [$.TEMP1]
        ld      E`x_offset      A`x_offset
        ld      D`x_offset      $00
        
        ld      L`mob_xpos      [IX+#mob.X+0]
        ld      H`mob_xpos      [IX+#mob.X+1]
        add     HL`mob_xpos     DE`x_offset
        
        ld      [IX+#mob.X+0]  L`mob_xpos
        ld      [IX+#mob.X+1]  H`mob_xpos
        
        ;get the Y-offset given in the parameter
        ld      A`x_offset      [$.TEMP2]
        ld      E`x_offset      A`x_offset      ;note that D is still zero
        
        ld      L`mob_ypos      [IX+#mob.Y+0]
        ld      H`mob_ypos      [IX+#mob.Y+1]
        add     HL`mob_ypos     DE`y_offset
        ld      [IX+#mob.Y+0]  L`mob_ypos
        ld      [IX+#mob.Y+1]  H`mob_ypos
        
        xor     A`zero
        ld      [IX+#mob.spriteLayout+0],A`zero
        ld      [IX+#mob.spriteLayout+1],A`zero
        
        ;play the explosion sound
        ld      A`sfx           $01
        rst     :rst_playSFX
        
        ;give the player 100 points
        ld      DE`hundreds     $0100
        ld      C`thousands     $00
        call    :increaseScore
        
        ret
}

PROC    :getFloorLayoutRAMAddressForMob         SECTION ::mobs                  ;$36F9
        ;===============================================================================
HELP ```Retrieves a location in the Floor Layout in RAM based on the current mob
        ```
PARAMS  IX`mob          ``Address of the current mob being processed
        BC`xOffset      ``Horizontal pixel offset to add to the mob's X position
                        ``before locating tile
        DE`yOffset      ``Vertical pixel offset to add to the mob's Y position
                        ``before locating tile
RETURN  HL`addr         ``An address within the floor layout in RAM
{
        ;how wide is the floor layout?
        ld      A`floorWidth    [$.LEVEL_FLOORWIDTH]
        cp      128
        jr      z,.width128
        cp      64
        jr      z,.width64
        cp      32
        jr      z,.width32
        cp      16
        jr      z,.width16
        
        jp      .width256
        
        ;-------------------------------------------------------------------------------
        ;128 block wide level:
        
.width128
        ld      L`mob_ypos      [IX+#mob.Y+0]
        ld      H`mob_ypos      [IX+#mob.Y+1]
        add     HL`mob_ypos     DE`yOffset
        ld      a,l
        add     a,a
        rl      h
        add     a,a
        rl      h
        and     %10000000
        ld      l,a
        ex      de,hl
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        add     hl,bc
        ld      a,l
        add     a,a
        rl      h
        add     a,a
        rl      h
        add     a,a
        rl      h
        ld      l,h
        ld      h,$00
        add     hl,de
        ld      de,$.FLOORLAYOUT
        add     hl,de
        ret
        
        ;-------------------------------------------------------------------------------
        ;64 block wide level:
        
.width64
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        add     hl,de
        ld      a,l
        add     a,a
        rl      h
        and     %11000000
        ld      l,a
        ex      de,hl
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        add     hl,bc
        ld      a,l
        add     a,a
        rl      h
        add     a,a
        rl      h
        add     a,a
        rl      h
        ld      l,h
        ld      h,$00
        add     hl,de
        ld      de,$.FLOORLAYOUT
        add     hl,de
        ret
        
        ;-------------------------------------------------------------------------------
        ;32 block wide level:
        
.width32
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        add     hl,de
        ld      a,l
        and     %11100000
        ld      l,a
        ex      de,hl
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        add     hl,bc
        ld      a,l
        add     a,a
        rl      h
        add     a,a
        rl      h
        add     a,a
        rl      h
        ld      l,h
        ld      h,$00
        add     hl,de
        ld      de,$.FLOORLAYOUT
        add     hl,de
        ret
        
        ;-------------------------------------------------------------------------------
        ;16 block wide level:
        
.width16
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        add     hl,de
        ld      a,l
        srl     h
        rra     
        and     %11110000
        ld      l,a
        ex      de,hl
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        add     hl,bc
        ld      a,l
        add     a,a
        rl      h
        add     a,a
        rl      h
        add     a,a
        rl      h
        ld      l,h
        ld      h,$00
        add     hl,de
        ld      de,$.FLOORLAYOUT
        add     hl,de
        ret
        
        ;-------------------------------------------------------------------------------
        ;256 block wide level?
        
.width256
        ld      L`mob_ypos      [IX+#mob.Y+0]
        ld      H`mob_ypos      [IX+#mob.Y+1]
        add     HL`mob_ypos     DE`yOffset
        ld      A`ypos          L`mob_ypos
        rlca                                    ;x2 ...
        rl      H`ypos
        rlca                                    ;x4 ...
        rl      H`ypos
        rlca                                    ;x8
        rl      H`ypos
        
        ;put Y-position aside into DE
        ex      DE`ypos         HL`yOffset
        
        ld      L`mob_xpos      [IX+#mob.X+0]
        ld      H`mob_xpos      [IX+#mob.X+1]
        add     HL`mob_xpos     BC`xOffset
        ld      A`xpos          L`mob_xpos
        rlca                                    ;x2 ...
        rl      H`xpos
        rlca                                    ;x4 ...
        rl      H`xpos
        rlca                                    ;x8
        rl      H`xpos
        ld      L`xpos          H`xpos
        
        ld      h,$00
        ld      e,h
        add     hl,de
        ld      DE`floorLayout  $.FLOORLAYOUT
        add     hl              DE`floorLayout
        ret
}

PROC    :updateSonicSpriteFrame                 SECTION ::mobs                  ;$37E0
        ;===============================================================================
HELP ```Copy the current Sonic animation frame into the sprite data
        ```
PARAMS  IY`vars         ``Address of the common variables (used throughout)
{        
        ld      DE`frameCurrent [$.SONIC_CURRENT_FRAME]
        ld      HL`framePrev    [$.SONIC_PREVIOUS_FRAME]
        
        ;has the animation advanced a frame?
        and     A`flags                         ;ANDing A with itself resets the flags
        sbc     HL`framePrev    DE`frameCurrent ;check the difference in frame counts
        ret     z                               ;exit if no progress
        
        ld      HL`vram         $3680           ;location in VRAM of the Sonic sprite
        ex      DE`vram         HL`discarded    ;TODO: make this dynamic, somehow
        
        ;;I can't find an instance where bit 0 of IY+$06 is set,
          this may be dead code;;
        bit     0, [iy+#vars.flags6]
        jp      nz, ._2
        
        ;-------------------------------------------------------------------------------
        ld      A`low           E`vram          ;$80
        out     [$_SMS_PORTS.VDP.CONTROL] A`low
        ld      A`hi            D`vram          ;$36
        or      %01000000                       ;set bit 6 to specify a VDP address
        out     [$_SMS_PORTS.VDP.CONTROL] A`hi
        
        xor     A`zero                          ;set A to 0
        ld      c, $_SMS_PORTS.VDP.DATA
        ld      e, 24
        
        ;; by nature of the way the VDP stores image colours across bit-planes, and
           that the Sonic sprite only uses palette indexes <8, the fourth byte for a
           tile row is always 0. this is used as a very simple form of compression on
           the Sonic sprites in the ROM as the fourth byte is excluded from the data ;;
._1     outi
        outi
        outi
        out     [$_SMS_PORTS.VDP.DATA]    A`zero
        outi
        outi
        outi
        out     [$_SMS_PORTS.VDP.DATA]    A`zero
        outi
        outi
        outi
        out     [$_SMS_PORTS.VDP.DATA]    A`zero
        outi
        outi
        outi
        out     [$_SMS_PORTS.VDP.DATA]    A`zero
        
        dec     e
        jp      nz, ._1
        
        ld      hl, [$.SONIC_CURRENT_FRAME]
        ld      [$.SONIC_PREVIOUS_FRAME], hl
        ret
        
        ;-------------------------------------------------------------------------------
        ;adds 285 to the frame address. purpose unknown...
._2     ld      bc, $011D
        add     hl, bc
        
        ld      a, e
        out     [$_SMS_PORTS.VDP.CONTROL], a
        ld      a, d
        or      %01000000
        out     [$_SMS_PORTS.VDP.CONTROL], a
        
        exx
        push    bc
        ld      b, $18
        exx
        ld      de, $FFFA
        ld      c, $BE
        xor     a`zero
        
._3     outi
        outi
        outi
        out     [$_SMS_PORTS.VDP.DATA], a
        add     hl, de
        outi
        outi
        outi
        out     [$_SMS_PORTS.VDP.DATA], a
        add     hl, de
        outi
        outi
        outi
        out     [$_SMS_PORTS.VDP.DATA], a
        add     hl, de
        outi
        outi
        outi
        out     [$_SMS_PORTS.VDP.DATA], a
        add     hl, de
        exx
        dec     b
        exx
        jp      nz, ._3
        
        exx
        pop     bc
        exx
        ld      hl, [$.SONIC_CURRENT_FRAME]
        ld      [$.SONIC_PREVIOUS_FRAME], hl
        ret
}

PROC    :updateRingFrame                        SECTION ::mobs                  ;$3879
        ;===============================================================================
{        
        ld      de,[$.RING_CURRENT_FRAME]
        ld      hl,[$.RING_PREVIOUS_FRAME]
        
        and     a
        sbc     hl,de
        ret     z
        
        ld      hl,$1f80                        ;location in VRAM of the ring graphics
        ex      de,hl
        di      
        ld      a,e
        out     [$_SMS_PORTS.VDP.CONTROL],a
        ld      a,d
        or      %01000000
        out     [$_SMS_PORTS.VDP.CONTROL],a
        ld      b,$20
        
.loop   ld      a,[hl]
        out     [$_SMS_PORTS.VDP.DATA],a
        nop     
        inc     hl
        ld      a,[hl]
        out     [$_SMS_PORTS.VDP.DATA],a
        nop     
        inc     hl
        ld      a,[hl]
        out     [$_SMS_PORTS.VDP.DATA],a
        nop     
        inc     hl
        ld      a,[hl]
        out     [$_SMS_PORTS.VDP.DATA],a
        inc     hl
        djnz    .loop
        
        ei      
        ld      hl,[$.RING_CURRENT_FRAME]
        ld      [$.RING_PREVIOUS_FRAME],hl
        ret
}

PROC    :_LABEL_38B0_51                         SECTION ::mobs                  ;$38B0
        ;===============================================================================
{        
        ld      hl, [$.D2AB]
        ld      a, l
        and     %11111000
        ld      l, a
        
        ld      de, [$.CAMERA_X]
        ld      a, e
        and     %11111000
        ld      e, a
        
        xor     a`zero                          ;set A to 0
        sbc     hl, de                          ;is DE > HL?
        ret     c
        
        or      h                               ;is H > 0?
        ret     nz
        
        ld      a, l
        cp      $08                             ;is L < 8?
        ret     c
        
        ld      d, a
        ld      a, [$.VDPSCROLL_HORZ]
        and     %11111000
        ld      e, a
        add     hl, de
        srl     h
        rr      l
        srl     h
        rr      l
        srl     h
        rr      l
        ld      a, l
        and     $1F
        add     a, a
        ld      c, a
        ld      hl, [$.D2AD]
        ld      a, l
        and     $F8
        ld      l, a
        ld      de, [$.CAMERA_Y]
        ld      a, e
        and     $F8
        ld      e, a
        xor     a`zero
        sbc     hl, de
        ret     c
        or      h
        ret     nz
        ld      a, l
        cp      $C0
        ret     nc
        ld      d, $00
        ld      a, [$.VDPSCROLL_VERT]
        and     $F8
        ld      e, a
        add     hl, de
        srl     h
        rr      l
        srl     h
        rr      l
        srl     h
        rr      l
        ld      a, l
        cp      $1C
        jr      c, ._1
        sub     $1C
._1     ld      l, a
        ld      h, $00
        ld      b, h
        rrca
        rrca
        ld      h, a
        and     $C0
        ld      l, a
        ld      a, h
        xor     l
        ld      h, a
        add     hl, bc
        ld      bc, $_SMS_VRAM.SCREENNAMETABLE
        add     hl, bc
        ld      de, [$.D2AF]
        ld      b, $02

.loop   ld      a, l
        out     [$_SMS_PORTS.VDP.CONTROL], a
        ld      a, h
        or      %01000000
        out     [$_SMS_PORTS.VDP.CONTROL], a
        
        ld      a, [de]
        out     [$_SMS_PORTS.VDP.DATA], a
        inc     de
        nop
        nop
        ld      a, [de]
        out     [$_SMS_PORTS.VDP.DATA], a
        inc     de
        nop
        nop
        ld      a, [de]
        out     [$_SMS_PORTS.VDP.DATA], a
        inc     de
        nop
        nop
        ld      a, [de]
        out     [$_SMS_PORTS.VDP.DATA], a
        inc     de
        
        ld      a, b
        ld      bc, $0040
        add     hl, bc
        ld      b, a
        djnz    .loop
        
        ret
}

PROC    :detectCollisionWithSonic               SECTION ::mobs                  ;$3956
        ;===============================================================================
HELP ```Tests to see if the given mob has collided with Sonic
        ```
PARAMS  IX`mob          ``Address of the current mob being processed
        IY`vars         ``Address of the common variables (used throughout)
        $.TEMP6         ``Left indent of the mob, in pixels
        $.TEMP7         ``Top indent of the mob, in pixels
RETURN  AF`carry        ``Carry flag is clear if collision, otherwise set
{
        ;is Sonic dead? (no collision detection)
        bit     0,[IY+#vars.scrollRingFlags]
        scf                                     ;return carry flag set (no-collision)
        ret     nz                              ;if Sonic-dead flag on, leave now
        
        ;-------------------------------------------------------------------------------
        
        ;calculate the right-hand edge of the mob
         ;(mob X-position + mob width)
        ld      L`mob_xpos      [IX+#mob.X+0]
        ld      H`mob_xpos      [IX+#mob.X+1]
        ld      C`mob_width     [IX+#mob.width]
        ld      B`mob_width     $00
        add     HL`mob_xpos     BC`mob_width
        
        ld      DE`sonic_xpos   [$.SONIC.X]
        
        ;is Sonic to the right of the mob?
        xor     A`zero                          ;set A to 0, clearing the carry flag
        sbc     HL`xpos         DE`sonic_xpos
        ret     c                               ;return carry-set for no-collision
        
        ;-------------------------------------------------------------------------------
        
        ;calculate the mob's left edge:
         ;note that the mob provides an 'indent'. the sprite may well begin at
         ;a certain X-position but the graphic within may be indented a little
        ld      L`mob_xpos      [IX+#mob.X+0]
        ld      H`mob_xpos      [IX+#mob.X+1]
        ld      A`mob_left      [$.TEMP6]       ;get the mob's left indent
        ld      C`mob_left      A`zero
        add     HL`mob_xpos     BC`mob_left     ;combine the two
        
        ;;now swap the mob's X-position with the previous calculation of Sonic's
          X-position. HL will be Sonic's X-position and DE will be the mob's;;
        ex      DE`mob_xpos     HL`sonic_xpos
        
        ;calculate Sonic's right edge:
        ld      A`sonic_width   [$.SONIC.width]
        ld      C`sonic_width   A`sonic_width   ;note that B is still 0
        add     HL`sonic_xpos   BC`sonic_width
        
        ;is Sonic to the left of the mob?
        xor     A`zero                          ;set A to 0, clearing the carry flag
        sbc     HL`sonic_xpos, DE`mob_xpos
        ret     c                               ;return carry-set for no-collision
        
        ;-------------------------------------------------------------------------------
        
        ;calculate the mob's bottom edge
        ld      L`mob_ypos      [IX+#mob.Y+0]
        ld      H`mob_ypos      [IX+#mob.Y+1]
        ld      C`mob_height    [IX+#mob.height]
        add     HL`mob_ypos     BC`mob_height
        
        ld      DE`sonic_ypos   [$.SONIC.Y]
        xor     A`zero                          ;set A to 0, clearing the carry flag
        sbc     HL`ypos         DE`sonic_ypos
        ret     c                               ;return carry-set for no-collision
        
        ;calculate the mob's top edge (including the indent)
        ld      L`mob_ypos      [IX+#mob.Y+0]
        ld      H`mob_ypos      [IX+#mob.Y+1]
        ld      A`mob_top       [$.TEMP7]
        ld      C`mob_top       A`mob_top
        add     HL`mob_ypos     BC`mob_top
        
        ex      DE              HL
        
        ld      A               [$.SONIC.height]
        ld      C               A
        add     HL              BC
        xor     A`zero                          ;set A to 0, clearing the carry flag
        sbc     HL              DE
        
        ret                                     ;return carry-set for no-collision
}

PROC    :increaseRings                          SECTION ::mobs                  ;$39AC
        ;===============================================================================
        ;NOTE: why does this not just use DAA?
PARAMS  A`count         ``Number of rings to add
{
        ;add the given number to the total ring count
        ld      C`count         A`count
        ld      A`rings         [$.RINGS]
        add     A`rings         C`count
        ld      C`rings         A`rings         ;move the new total to C
        
        and     %00001111                       ;look at the last digit $0-$F
        cp      10                              ;is it above $A? (11-16)
        jr      c,.is100rings                           
        
        ld      A`rings         C`rings
        add     A`rings         $06             ;TODO: WHY????
        ld      C`rings         A`rings
        
        ;-------------------------------------------------------------------------------
        
.is100rings
        ld      A`rings         C`rings
        cp      $A0
        jr      c,.pickupRing                   ;if not yet 100, keep going
        
        ;subtract 100 rings
        sub     $A0
        ld      [$.RINGS]       A`rings
        
        ;add 1 to the lives count
        ld      A`lives         [$.LIVES]
        inc     A`lives
        ld      [$.LIVES]       A`lives
        
        ;play the 1-up sound effect
        ld      A`sfx           $09
        rst     :rst_playSFX
        
        ret
        
        ;-------------------------------------------------------------------------------
        
.pickupRing
        ;update the ring total
        ld      [$.RINGS]       A`rings
        ;play the pickup-ring sound
        ld      A`sfx           $02
        rst     :rst_playSFX
        
        ret
}

PROC    :increaseScore                          SECTION ::mobs                  ;$39D8
        ;===============================================================================
PARAMS  C`thousands     ``Thousands to add to the score
        D`hundreds      ``Hundreds to add to the score
        E`tens          ``Tens to add to the score 
{
        ld      HL`score        $.SCORE_TENS    ;read the tens unit of the score
        ld      A`tens          E`tens          ;handle the amount to add
        add     A`tens          [HL`score]      ;add the tens to the score
        daa                                     ;adjust to binary-coded-decimal
        ld      [HL`score]      A`tens          ;save the new tens value
        
        dec     HL`score                        ;move down to hundreds units
        ld      A`hundreds      D`hundreds      ;handle the amount to add
        adc     A`hundreds      [HL`score]      ;add the hundreds to the score
        daa                                     ;adjust to binary-coded-decimal
        ld      [HL`score]      A`hundreds      ;save the new hundreds value
        
        dec     HL`score                        ;move down to thousands units
        ld      A`thousands     C`thousands     ;handle the amount to add
        adc     A`thousands     [HL`score]      ;add the thousands to the score
        daa                                     ;adjust to binary-coded-decimal
        ld      [HL`score]      A`thousands     ;save the new thousands value
        
        ;push the current thousands value to the side
        ld      C`thousands     A`thousands
        
        dec     HL`score                        ;move down to millions units
        ld      A`millions      $00
        adc     A`millions      [HL`score]
        daa     
        ld      [HL`score]      A`millions
        
        ;-------------------------------------------------------------------------------
        
        ;check if current score qualifies for an extra life
        ld      HL`score_1up    $.SCORE_1UP
        ld      A`thousands     C`thousands
        cp      [HL`score_1up]
        ret     c
        
        ;increase the score requirement for an extra life to the next multiple
        ld      A`score_1up     !SCORE_1UP
        add     A`score_1up     [HL`score_1up]
        daa                                     ;adjust to binary-coded-decimal
        ld      [HL`score_1up]  A`score_1up
        
        ;add an extra life
        ld      HL`lives        $.LIVES
        inc     [HL`lives]
        ;play extra life sound effect
        ld      A`sfx           $09
        rst     :rst_playSFX
        
        ret
}

PROC    :updateTime                             SECTION ::mobs                  ;$3A03
        ;===============================================================================
        ;called only by `:_LABEL_1CED_131`; main game loop?
        
PARAMS  IY`vars         ``Address of the common variables (used throughout)
{        
        ;is Sonic dead? if so, exit now
        bit     0,[IY`vars+#vars.scrollRingFlags]
        ret     nz
        
        ;address of level time?
        ld      HL              $.TIME_FRAMES
        
        ;is the time counting down? (special stages)
        bit     0,[IY+#vars.timeLightningFlags]
        jr      nz .countdown
        
        ;time is counting up:
        ;-------------------------------------------------------------------------------
        
        ;wait 60 frames for a second
         ;(TODO: detect PAL/NTSC and use the correct frame rate)
        ld      A`frames        [HL`time]       ;load the current frame-count
        inc     A`frames                        ;add another frame
        cp      60                              ;is it 60 or less?
        jr      c ._1                           ;if so, keep going
        xor     A`zero                          ;otherwise, set frame-count to 0
._1     ld      [HL`time]       A`frames        ;update the frame counter
        
        ;increase seconds counter:
        dec     HL`time                         ;move down to the seconds counter
        ccf                                     ;flip the carry flag
        ld      A`seconds       [HL`time]       ;read the number of seconds
        adc     A`seconds       $00             ;if frame count hit 60, add a second
        daa                                     ;adjust up to binary-coded-decimal
        cp      $60                             ;60 seconds? (BCD)
        jr      c ._2                           ;if not, keep going
        xor     A`zero                          ;otherwise, set A to 0
._2     ld      [HL`time]       A`seconds       ;update the seconds counter
        
        ;increase minutes counter:
        dec     HL`time                         ;move down to the minute counter
        ccf                                     ;flip the carry flag
        ld      A`minutes       [HL`time]       ;read the number of minutes
        adc     A`minutes       $00             ;if seconds hit 60, add a minute
        daa                                     ;adjust up to binary-coded-decimal
        cp      $10                             ;10 minutes?
        jr      c ._3                           ;if not, keep going
        
        push    HL`time                         ;put the minute counter addr aside
        call    :hitPlayer.kill                 ;go do out-of-time
        pop     HL`time                         ;go back to the minute counter addr
        xor     A`zero                          ;reset to 0
        
._3     ld      [HL`time]       A`minutes       ;update the minute counter
        ret                                     ;exit!
        
        ;time is counting down:
        ;-------------------------------------------------------------------------------
.countdown
        ;wait 60 frames for a second
         ;(TODO: this is a repeat of above, so could be re-organised to share)
        ld      A`frames        [HL`time]       ;load the current frame-count
        inc     A`frames                        ;add another frame
        cp      60                              ;is it 60 or less?
        jr      c ._5                           ;if so, keep going
        xor     A`zero                          ;otherwise, set frame-count to 0
._5     ld      [HL`time]       A`frames        ;update the frame counter
        
        dec     HL`time                         ;move down to the seconds counter
        ccf                                     ;flip the carry flag
        ld      A`seconds       [HL`time]       ;read the number of seconds
        sbc     A`seconds       $00             ;if frame count hit 60 remove a second
        daa                                     ;adjust up to binary-coded-decimal
        cp      $60                             ;when seconds hit zero, no carry
        jr      c ._6                           ;above 0 seconds, keep going
        ld      A`seconds       $59             ;otherwise, loop around to 59 seconds
._6     ld      [HL`time]       A`seconds       ;update the seconds counter
        
        dec     HL`time                         ;move down to the minutes counter
        ccf                                     ;flip the carry flag
        ld      A`minutes       [HL`time]       ;read the number of minutes
        sbc     A`minutes       $00             ;if seconds hit 0, remove a minute
        daa                                     ;adjust up to binary-coded-decimal
        cp      $60                             ;when minutes hit zero, no carry
        jr      c ._7                           ;above 0 minutes, keep going
        
        ;set some flags?
        ld      A               $01
        ld      [$.D289]        A
        set     2,[IY+#vars.flags9]
        
        xor     A`zero
._7     ld      [HL`time]       A`zero
        
        ret
}

        ;seemingly unused?
TABLE   :_3a62                                  SECTION ::mobs                  ;$3A62
{
        BYTE    $01, $30, $00
}

;solidity pointer table
TABLE   :S1_Solidity_Blocks                     SECTION ::mobs                  ;$3A65
{
        WORD    .greenHill      .bridge         .jungle
        WORD    .labyrinth      .scrapBrain     .skyBaseInterior
        WORD    .specialStage   .skyBaseExterior

INDEX   .greenHill                                                              ;$3A75
        
        ;00 = sky
        ;16 = solid
        ;10 = flat ground
        ;08 = slope up 1
        ;09 = slope up 2
        ;0A = slope up 3
        ;05 = slope down 1
        ;06 = slope down 2
        ;07 = slope down 3
        ;03 = slope steep up 1
        ;04 = slope steep up 2
        ;01 = slope steep down 1
        ;02 = slope steep down 2
        ;0C = dip down 1
        ;0D = dip up 1
        ;0E = dip down 2
        ;0F = dip up 2
        ;0B = dip
        ;12 = Edge down
        ;15 = Edge up
        ;1E = ceiling
        ;11 = ramp
        ;27 = ? (also ground)
        ;14 = edge ground
        
        BYTE    $00 $16 $10 $10 $10 $00 $00 $08 $09 $0A $05 $06 $07 $03 $04 $01
        BYTE    $02 $10 $00 $00 $00 $10 $10 $00 $00 $00 $10 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $10 $00 $00 $00 $00 $00 $00 $00 $10 $10 $0C
        BYTE    $0D $0E $0F $0B $10 $10 $10 $10 $00 $10 $10 $10 $00 $10 $10 $10
        BYTE    $10 $10 $10 $10 $10 $16 $16 $12 $10 $15 $00 $00 $10 $16 $1E $16
        BYTE    $11 $10 $00 $10 $10 $1E $1E $1E $10 $1E $00 $00 $16 $1E $16 $1E
        BYTE    $00 $27 $1E $00 $27 $27 $27 $27 $27 $16 $27 $27 $00 $00 $00 $00
        BYTE    $00 $00 $00 $14 $00 $00 $05 $0A $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $80 $80 $90 $80 $96 $90 $80 $90 $80 $80 $80 $A7 $A7 $A7 $A7 $A7
        BYTE    $A7 $A7 $A7 $A7 $A7 $00 $00 $00 $00 $90 $9E $80 $80 $80 $80 $80
        BYTE    $90 $00 $00 $00 $00 $00 $00 $00
        
 INDEX  .bridge                                                                 ;$3B2D
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $13 $10 $12 $12 $13 $00 $00 $00 $00 $00 $00 $10 $10 $00 $00 $00
        BYTE    $12 $13 $10 $13 $12 $00 $00 $00 $07 $2B $00 $00 $08 $00 $09 $06
        BYTE    $05 $29 $10 $2A $0A $00 $00 $00 $10 $10 $2E $00 $2D $00 $00 $00
        BYTE    $00 $00 $80 $80 $80 $00 $80 $80 $80 $80 $00 $00 $80 $00 $00 $80
        BYTE    $2C $27 $10 $00 $00 $00 $80 $80 $10 $16 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $12 $10 $13 $00 $00 $10 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $13 $16 $16 $12 $00 $00 $00 $00 $10 $2D $2E $00 $00 $00 $00 $00
        
INDEX .jungle                                                                   ;$3BBD
        BYTE    $00 $10 $00 $00 $00 $00 $00 $00 $10 $10 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $10 $10 $10 $10 $10 $10 $10 $16 $16 $16 $16 $27 $16
        BYTE    $1E $10 $10 $00 $00 $00 $00 $00 $00 $10 $00 $00 $10 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $27 $00 $00 $10
        BYTE    $11 $00 $01 $00 $00 $10 $10 $00 $04 $01 $02 $03 $06 $07 $05 $08
        BYTE    $09 $0A $10 $0E $0F $05 $0A $04 $01 $10 $10 $17 $00 $0B $05 $14
        BYTE    $0A $00 $10 $27 $10 $00 $00 $00 $10 $1E $00 $10 $10 $00 $00 $10
        BYTE    $10 $10 $00 $00 $00 $1E $00 $27 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $80 $80 $80 $80 $80 $A7 $80 $27 $A7 $A7 $A7 $A7 $A7 $A7 $A7
        BYTE    $A7 $A7 $80 $80 $10 $10 $96 $96 $16 $16 $16 $16 $00 $00 $00 $00

INDEX   .labyrinth                                                              ;$35CD
        BYTE    $00 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16
        BYTE    $16 $16 $16 $16 $16 $16 $16 $16 $00 $00 $00 $00 $00 $00 $80 $27
        BYTE    $00 $00 $00 $00 $00 $00 $80 $27 $00 $00 $00 $00 $00 $27 $A7 $16
        BYTE    $00 $00 $1E $27 $00 $1E $00 $27 $00 $27 $00 $16 $27 $27 $9E $80
        BYTE    $1E $1E $1E $16 $16 $16 $16 $16 $27 $1E $1E $16 $16 $16 $16 $16
        BYTE    $06 $07 $00 $00 $08 $09 $02 $01 $12 $05 $14 $15 $0A $13 $04 $03
        BYTE    $04 $00 $04 $03 $08 $09 $06 $07 $03 $01 $02 $01 $0A $06 $09 $05
        BYTE    $00 $00 $04 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $16 $16 $10 $16 $16 $16 $16 $16 $00 $27 $16 $16 $16 $16 $00
        BYTE    $1E $00 $27 $1E $00 $1E $00 $00 $01 $04 $01 $04 $09 $06 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $A8 $00 $00 $00 $00 $00 $00 $00

INDEX   .scrapBrain                                                             ;$3D0D
        BYTE    $00 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $1E $1E $1E $1A
        BYTE    $1B $1C $1D $1F $20 $21 $22 $23 $24 $1B $1C $16 $1E $1E $1E $1E
        BYTE    $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $16 $27
        BYTE    $27 $27 $04 $03 $02 $01 $08 $09 $0A $05 $06 $07 $0A $05 $03 $02
        BYTE    $15 $14 $16 $16 $13 $12 $10 $10 $10 $10 $10 $10 $10 $10 $16 $27
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $1E $00 $1E $1E $1E $00 $00 $10 $80 $80 $27 $27 $27
        BYTE    $16 $16 $27 $27 $27 $1E $1E $16 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $02 $03 $90 $80 $9E $16 $16 $02 $03 $1B $1C $16 $16 $19 $18
        BYTE    $25 $26 $00 $00 $00 $27 $27 $1E $1E $27 $1E $00 $00 $00 $00 $1E
        BYTE    $27 $1E $27 $9E $9E $16 $16 $00 $00 $1E $16 $1E $1E $90 $90 $90
        BYTE    $16 $16 $16 $16 $00 $00 $00 $00 $A7 $9E $00
        
INDEX   .skyBaseInterior                                                        ;$3DC8
        BYTE    $00 $10 $16 $16 $10 $10 $10 $10 $10 $00 $00 $16 $16 $1E $00 $00
        BYTE    $00 $00 $10 $10 $10 $00 $90 $80 $1E $00 $00 $00 $10 $10 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $03 $04 $00 $00 $08 $09 $0A $16 $13
        BYTE    $15 $02 $01 $00 $07 $06 $05 $16 $14 $12 $0A $05 $10 $10 $00 $00
        BYTE    $03 $02 $10 $00 $00 $10 $00 $00 $00 $00 $00 $00 $00 $00 $10 $10
        BYTE    $10 $00 $00 $10 $00 $10 $00 $00 $00 $10 $10 $10 $10 $16 $16 $04
        BYTE    $03 $03 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $10 $10 $16 $00 $10 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $16 $00 $00 $00 $00 $00 $00 $00 $00 $10 $00 $00 $00 $00 $00 $00
        BYTE    $00 $1E $00 $00 $00 $1E $1E $10 $00 $00 $10 $10 $1E $1E $16 $16
        BYTE    $1E $1E $1E $1E $1E $00 $10 $1E $1E $10 $10 $1E $00 $02 $0A $16
        BYTE    $00 $00 $00 $00 $00 $00 $10 $1E $16 $1E $00 $10 $10 $10 $10 $10
        BYTE    $1E $00 $10 $00 $00 $10 $10 $10 $10 $1E $90 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $9E $1E $00 $00 $00 $00 $00 $00 $00 $00 $00
        
INDEX   .specialStage                                                           ;$3EA8 
        BYTE    $00 $27 $27 $27 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $1E $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $27 $00 $00 $00 $00 $00 $27 $27 $16 $00 $00 $00
        BYTE    $27 $1E $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        
INDEX   .skyBaseExterior                                                        ;$3F28 
        BYTE    $00 $27 $27 $16 $1E $1E $16 $27 $27 $1E $1E $00 $00 $16 $27 $27
        BYTE    $16 $1E $1E $16 $16 $16 $16 $01 $02 $04 $03 $1D $1C $1A $1B $01
        BYTE    $02 $04 $03 $1D $1C $1A $1B $00 $00 $00 $00 $00 $00 $00 $16 $9E
        BYTE    $9E $80 $1E $27 $A7 $A7 $80 $80 $16 $16 $80 $1E $1E $27 $27 $27
        BYTE    $16 $1E $16 $16 $16 $16 $16 $16 $27 $00 $1E $00 $00 $00 $00 $00
        BYTE    $00 $00 $16 $16 $16 $16 $16 $16 $16 $16 $A7 $A7 $9E $9E $16 $00
        BYTE    $9E $A7 $80 $9E $A7 $80 $00 $00 $00 $1C $1C $E4 $E4 $12 $12 $12
        BYTE    $EE $EE $EE $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $12 $EE $00 $00 $00 $00
}

TABLE   :UnknownCollision                       SECTION ::mobs                  ;$3FBF
{
        ;47 entries, according to number of solidity types
._3FBF  BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 ;$3FBF
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        
        ;junk data?
        BYTE    $00 $00
        
        ;47 entries, according to number of solidity types
._3FF0  BYTE    $00 $08 $08 $08 $08 $06 $06 $06 $06 $06 $06 $03 $03 $03 $03 $03
        BYTE    $03 $08 $03 $03 $03 $03 $03 $03 $00 $00 $00 $00 $00 $00 $00 $00 ;$4000
        BYTE    $00 $00 $00 $00 $00 $00 $00 $03 $03 $04 $04 $03 $03 $03 $03
        
        ;junk data?
        BYTE    $00
}

;referenced by ":doMobCommon"
;something to do with mob floor collision

TABLE   :Unknown                                SECTION ::mobs                  ;$4020
{        
        ;this is a lookup table using block solidity as index
._4020  WORD    ._407E, ._407E, ._407E, ._407E, ._407E, ._407E, ._407E, ._407E  ;$4020
        WORD    ._407E, ._407E, ._407E, ._407E, ._407E, ._407E, ._407E, ._407E
        WORD    ._407E, ._407E, ._407E, ._407E, ._407E, ._407E, ._409E, ._407E
        WORD    ._407E, ._407E, ._407E, ._407E, ._407E, ._407E, ._40BE, ._407E
        WORD    ._407E, ._407E, ._407E, ._407E, ._407E, ._407E, ._407E, ._40DE
        WORD    ._40FE, ._407E, ._407E, ._407E, ._407E, ._407E, ._407E
        
._407E  BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 ;$407E
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80
        
._409E  BYTE    $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C ;$409E
        BYTE    $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C
        
._40BE  BYTE    $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C ;$40BE
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80
        
._40DE  BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 ;$40DE
        BYTE    $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C $1C
        
._40FE  BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $1C $1C $1C $1C $1C $1C $1C $1C ;$40FE
        BYTE    $1C $1C $1C $1C $1C $1C $1C $1C $80 $80 $80 $80 $80 $80 $80 $80
        
        ;-------------------------------------------------------------------------------
        
._411E  WORD    ._407E ._407E ._407E ._407E ._407E ._407E ._407E ._407E         ;$411E
        WORD    ._407E ._407E ._407E ._407E ._407E ._407E ._407E ._407E
        WORD    ._407E ._407E ._407E ._407E ._407E ._407E ._417C ._407E
        WORD    ._407E ._407E ._407E ._407E ._407E ._407E ._418C ._407E
        WORD    ._407E ._407E ._407E ._407E ._407E ._407E ._407E ._41AC
        WORD    ._41CC ._407E ._407E ._407E ._407E ._407E ._407E
        
._417C  BYTE    $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 ;$417C
        BYTE    $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04
        
._418C  BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 ;$418C
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80
        
._41AC  BYTE    $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 $04 ;$41AC
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $04 $04 $04 $04 $04 $04 $04 $04
        
        ;junk data?
        BYTE    $04 $04 $04 $04 $04 $04 $04 $04 $80 $80 $80 $80 $80 $80 $80 $80
        
        ;-------------------------------------------------------------------------------
        
._41EC  WORD    ._407E ._407E ._407E ._407E ._407E ._407E ._407E ._407E         ;$41EC
        WORD    ._407E ._407E ._407E ._407E ._407E ._407E ._407E ._407E
        WORD    ._407E ._407E ._407E ._407E ._407E ._407E ._424A ._407E
        WORD    ._426A ._428A ._42AA ._42CA ._42EA ._430A ._432A ._434A
        WORD    ._436A ._438A ._43AA ._43CA ._43EA ._440A ._442A ._444A
        WORD    ._446A ._407E ._407E ._407E ._407E ._407E ._407E
        
._424A  BYTE    $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F ;$424A
        BYTE    $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F
        
._426A  BYTE    $18 $18 $17 $17 $16 $16 $15 $15 $14 $14 $13 $13 $12 $12 $11 $11 ;$426A
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10
        
._428A  BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 ;$428A
        BYTE    $11 $11 $12 $12 $13 $13 $14 $14 $15 $15 $16 $16 $17 $17 $18 $18
        
._42AA  BYTE    $0F $0E $0D $0C $0B $0A $09 $08 $07 $06 $05 $04 $03 $02 $01 $00 ;$42AA
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80
        
._42CA  BYTE    $2F $2E $2D $2C $2B $2A $29 $28 $27 $26 $25 $24 $23 $22 $21 $20 ;$42CA
        BYTE    $1F $1E $1D $1C $1B $1A $19 $18 $17 $16 $15 $14 $13 $12 $11 $10
        
._42EA  BYTE    $10 $11 $12 $13 $14 $15 $16 $17 $18 $19 $1A $1B $1C $1D $1E $1F ;$42EA
        BYTE    $20 $21 $22 $23 $24 $25 $26 $27 $28 $29 $2A $2B $2C $2D $2E $2F
        
._430A  BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 ;$430A
        BYTE    $00 $01 $02 $03 $04 $05 $06 $07 $08 $09 $0A $0B $0C $0D $0E $0F
        
._432A  BYTE    $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F ;$432A
        BYTE    $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F $0F
        
._434A  BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 ;$434A
        BYTE    $00 $00 $01 $01 $02 $02 $03 $03 $04 $04 $05 $05 $06 $06 $07 $07
        
._436A  BYTE    $08 $08 $09 $09 $0A $0A $0B $0B $0C $0C $0D $0D $0E $0E $0F $0F ;$436A
        BYTE    $10 $10 $11 $11 $12 $12 $13 $13 $14 $14 $15 $15 $16 $16 $17 $17
        
._438A  BYTE    $18 $18 $19 $19 $1A $1A $1B $1B $1C $1C $1D $1D $1E $1E $1F $1F ;$438A
        BYTE    $20 $20 $21 $21 $22 $22 $23 $23 $24 $24 $25 $25 $26 $26 $27 $27
        
._43AA  BYTE    $27 $27 $26 $26 $25 $25 $24 $24 $23 $23 $22 $22 $21 $21 $20 $20 ;$43AA
        BYTE    $1F $1F $1E $1E $1D $1D $1C $1C $1B $1B $1A $1A $19 $19 $18 $18
        
._43CA  BYTE    $17 $17 $16 $16 $15 $15 $14 $14 $13 $13 $12 $12 $11 $11 $10 $10 ;$43CA
        BYTE    $0F $0F $0E $0E $0D $0D $0C $0C $0B $0B $0A $0A $09 $09 $08 $08
        
._43EA  BYTE    $07 $07 $06 $06 $05 $05 $04 $04 $03 $03 $02 $02 $01 $01 $00 $00 ;$43EA
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80
        
._440A  BYTE    $08 $08 $09 $09 $0A $0A $0B $0B $0C $0C $0D $0D $0E $0E $0F $0F ;$440A
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10
        
._442A  BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 ;$442A
        BYTE    $0F $0F $0E $0E $0D $0D $0C $0C $0B $0B $0A $0A $09 $09 $08 $08
        
._444A  BYTE    $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F ;$444A
        BYTE    $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F $1F
        
._446A  BYTE    $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 ;$446A
        BYTE    $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17 $17
        
        ;-------------------------------------------------------------------------------
        
._448A  BYTE    ._407E ._44E8 ._4508 ._4528 ._4548 ._4568 ._4588 ._45A8         ;$448A
        BYTE    ._45C8 ._45E8 ._4608 ._4628 ._4648 ._4668 ._4688 ._46A8
        BYTE    ._46C8 ._46E8 ._4708 ._4728 ._4748 ._4768 ._4788 ._47A8
        BYTE    ._407E ._407E ._407E ._407E ._407E ._407E ._407E ._407E
        BYTE    ._407E ._407E ._407E ._407E ._407E ._407E ._407E ._47C8
        BYTE    ._47E8 ._4808 ._4828 ._4848 ._4868 ._4888 ._48A8
        
._45E8  BYTE    $10 $11 $12 $13 $14 $15 $16 $17 $18 $19 $1A $1B $1C $1D $1E $1F ;$45E8
        BYTE    $20 $21 $22 $23 $24 $25 $26 $27 $28 $29 $2A $2B $2C $2D $2E $2F
        
._4608  BYTE    $F0 $F1 $F2 $F3 $F4 $F5 $F6 $F7 $F8 $F9 $FA $FB $FC $FD $FE $FF ;$4608
        BYTE    $00 $01 $02 $03 $04 $05 $06 $07 $08 $09 $0A $0B $0C $0D $0E $0F
        
._4628  BYTE    $0F $0E $0D $0C $0B $0A $09 $08 $07 $06 $05 $04 $03 $02 $01 $00 ;$4628
        BYTE    $FF $FE $FD $FC $FB $FA $F9 $F8 $F7 $F6 $F5 $F4 $F3 $F2 $F1 $F0
        
._4648  BYTE    $2F $2E $2D $2C $2B $2A $29 $28 $27 $26 $25 $24 $23 $22 $21 $20 ;$4648
        BYTE    $1F $1E $1D $1C $1B $1A $19 $18 $17 $16 $15 $14 $13 $12 $11 $10
        
._4668  BYTE    $F8 $F8 $F9 $F9 $FA $FA $FB $FB $FC $FC $FD $FD $FE $FE $FF $FF ;$4668
        BYTE    $00 $00 $01 $01 $02 $02 $03 $03 $04 $04 $05 $05 $06 $06 $07 $07
        
._4688  BYTE    $08 $08 $09 $09 $0A $0A $0B $0B $0C $0C $0D $0D $0E $0E $0F $0F ;$4688
        BYTE    $10 $10 $11 $11 $12 $12 $13 $13 $14 $14 $15 $15 $16 $16 $17 $17
        
._46A8  BYTE    $18 $18 $19 $19 $1A $1A $1B $1B $1C $1C $1D $1D $1E $1E $1F $1F ;$46A8
        BYTE    $20 $20 $21 $21 $22 $22 $23 $23 $24 $24 $25 $25 $26 $26 $27 $27
        
._46C8  BYTE    $27 $27 $26 $26 $25 $25 $24 $24 $23 $23 $22 $22 $21 $21 $20 $20 ;$46C8
        BYTE    $1F $1F $1E $1E $1D $1D $1C $1C $1B $1B $1A $1A $19 $19 $18 $18
        
._46E8  BYTE    $17 $17 $16 $16 $15 $15 $14 $14 $13 $13 $12 $12 $11 $11 $10 $10 ;$46E8
        BYTE    $0F $0F $0E $0E $0D $0D $0C $0C $0B $0B $0A $0A $09 $09 $08 $08
        
._4708  BYTE    $07 $07 $06 $06 $05 $05 $04 $04 $03 $03 $02 $02 $01 $01 $00 $00 ;$4708
        BYTE    $FF $FF $FE $FE $FD $FD $FC $FC $FB $FB $FA $FA $F9 $F9 $F8 $F8
        
._4728  BYTE    $10 $10 $10 $10 $10 $10 $10 $11 $11 $11 $11 $11 $12 $12 $12 $12 ;$4728
        BYTE    $12 $12 $12 $12 $12 $11 $11 $11 $11 $11 $10 $10 $10 $10 $10 $10
        
._4748  BYTE    $10 $10 $10 $10 $10 $10 $10 $11 $11 $11 $11 $11 $12 $12 $12 $12 ;$4748
        BYTE    $13 $13 $13 $14 $14 $15 $15 $15 $16 $16 $16 $17 $17 $17 $17 $17
        
._4768  BYTE    $17 $17 $17 $17 $17 $16 $16 $16 $15 $15 $15 $14 $14 $13 $13 $13 ;$4768
        BYTE    $12 $12 $12 $12 $11 $11 $11 $11 $11 $10 $10 $10 $10 $10 $10 $10
        
._4788  BYTE    $08 $08 $08 $08 $08 $08 $08 $09 $09 $09 $09 $09 $0A $0A $0A $0A ;$4788
        BYTE    $0B $0B $0B $0C $0C $0D $0D $0D $0E $0E $0E $0F $0F $0F $0F $0F
        
._47A8  BYTE    $0F $0F $0F $0F $0F $0E $0E $0E $0D $0D $0D $0C $0C $0B $0B $0B ;$47A8
        BYTE    $0A $0A $0A $0A $09 $09 $09 $09 $09 $08 $08 $08 $08 $08 $08 $08
        
._47C8  BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 ;$47C8
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10
        
._47E8  BYTE    $10 $11 $12 $13 $14 $15 $16 $17 $18 $19 $19 $1A $1A $1A $1B $1B ;$47E8
        BYTE    $1B $1B $1B $1A $1A $1A $19 $19 $18 $17 $16 $14 $11 $10 $10 $10
        
._4808  BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 ;$4808
        BYTE    $11 $11 $12 $12 $13 $13 $14 $14 $15 $15 $16 $16 $17 $17 $18 $18
        
._4828  BYTE    $18 $18 $17 $17 $16 $16 $15 $15 $14 $14 $13 $13 $12 $12 $11 $11 ;$4828
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10
        
._4848  BYTE    $08 $08 $09 $09 $0A $0A $0B $0B $0C $0C $0D $0D $0E $0E $0F $0F ;$4848
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10
        
._4868  BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 ;$4868
        BYTE    $0F $0F $0E $0E $0D $0D $0C $0C $0B $0B $0A $0A $09 $09 $08 $08
        
._4888  BYTE    $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF ;$4888
        BYTE    $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF $FF
        
._48A8  BYTE    $08 $08 $08 $08 $09 $09 $09 $09 $0A $0A $0A $0A $0B $0B $0B $0B ;$48A8
        BYTE    $0B $0B $0B $0B $0A $0A $0A $0A $09 $09 $09 $09 $08 $08 $08 $08
        
        ;unused?
._48C8  BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 ;$48C8
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10
        
        ;unused?
._48E8  BYTE    $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 ;$48E8
        BYTE    $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08 $08
        
._4908  BYTE    $08 $08 $08 $08 $09 $09 $09 $09 $0A $0A $0A $0A $0B $0B $0B $0B ;$4908
        BYTE    $0C $0C $0C $0C $0D $0D $0D $0D $0E $0E $0E $0E $0F $0F $0F $0F
        
        ;unused?
._4928  BYTE    $0F $0F $0F $0F $0E $0E $0E $0E $0D $0D $0D $0D $0C $0C $0C $0C ;$4928
        BYTE    $0B $0B $0B $0B $0A $0A $0A $0A $09 $09 $09 $09 $08 $08 $08 $08
        
        ;unused?
._4948  BYTE    $07 $07 $06 $06 $05 $05 $04 $04 $03 $03 $02 $02 $01 $01 $00 $00 ;$4948
        BYTE    $00 $00 $01 $01 $02 $02 $03 $03 $04 $04 $05 $05 $06 $06 $07 $07
        
        ;unused?
._4968  BYTE    $08 $08 $08 $08 $09 $09 $09 $09 $0A $0A $0A $0A $0B $0B $0C $0C ;$4968
        BYTE    $0C $0C $0B $0B $0A $0A $0A $0A $09 $09 $09 $09 $08 $08 $08 $08
        
        ;unused?
._4988  BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 ;$4988
        BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10
        
        ;unused?
._49A8  BYTE    $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 $10 ;$49A8
        BYTE    $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80 $80
}

;=======================================================================================

INCLUDE "mobs\sonic.oz80"

INCLUDE "mobs\powerups_common.oz80"
INCLUDE "mobs\boss_endSign.oz80"

;---------------------------------------------------------------------------------------
;and for whatever reason, the original ROM wedges the level palettes right here!

INCLUDE "palettes.oz80"

;---------------------------------------------------------------------------------------

INCLUDE "mobs\badnick_crabmeat.oz80"
INCLUDE "mobs\platform_swinging.oz80"
INCLUDE "mobs\explosion.oz80"
INCLUDE "mobs\platform.oz80"
INCLUDE "mobs\platform_falling.oz80"
INCLUDE "mobs\unknown_6ac1.oz80"
INCLUDE "mobs\badnick_buzzbomber.oz80"
INCLUDE "mobs\platform_moving.oz80"
INCLUDE "mobs\badnick_motobug.oz80"
INCLUDE "mobs\badnick_newtron.oz80"
INCLUDE "mobs\boss_greenHill.oz80"

TABLE   :S1_BossPalette                         SECTION ::mobs                  ;$731C
{
        BYTE    $38 $20 $35 $1B $16 $2A $00 $3F $15 $3A $0F $03 $01 $02 $3E $00 
}

INCLUDE "mobs\boss_capsule.oz80"
INCLUDE "mobs\boss_animals.oz80"


PROC    :_77be                                  SECTION ::mobs                  ;$77BE
        ;===============================================================================
        ;called by the boss mob code -- probably the exploded egg ship

PARAMS  IX`mob          ``Address of the current mob being processed
{
        ld      a,[$.D2EC]
        cp      $08
        jr      nc,._4
        ld      a,[$.D2B1]
        and     a
        jp      nz,._2
        ld      hl,$0c08
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        ret     c
        bit     0,[iy+#vars.scrollRingFlags]
        ret     nz
        ld      a,[$.SONIC.flags]
        rrca    
        jr      c,._1
        and     $02
        jp      z,:hitPlayer._35fd
._1     ld      de,$0001
        ld      hl,[$.SONIC.Yspeed]
        ld      a,l
        cpl     
        ld      l,a
        ld      a,h
        cpl     
        ld      h,a
        ld      a,[$.SONIC.Ydirection]
        cpl     
        add     hl,de
        adc     a,$00
        ld      [$.SONIC.Yspeed],hl
        ld      [$.SONIC.Ydirection],a
        
        ;stop Sonic's movement (reset speed and direction)
        xor     a`zero                          ;set A to 0
        ld      l`zero,a`zero
        ld      h`zero,a`zero
        ld      [$.SONIC.Xspeed],hl`zero
        ld      [$.SONIC.Xdirection],a`zero
        
        ld      a,$18
        ld      [$.D2B1],a
        ld      a,$8f
        ld      [$.D2B1+1],a
        ld      a,$3f
        ld      [$.D2B3],a
        
        ld      a,$01
        rst     :rst_playSFX
        
        ld      a,[$.D2EC]
        inc     a
        ld      [$.D2EC],a
        
._2     ld      hl,[$.D216]
        ld      de,._7922
        add     hl,de
        bit     1,[ix+#mob.flags]
        jr      z,._3
        ld      de,$0012
        add     hl,de
._3     ld      [ix+#mob.spriteLayout+0],l
        ld      [ix+#mob.spriteLayout+1],h
        
        ld      hl,$.D2ED
        ld      [hl],$18
        inc     hl
        ld      [hl],$00
        ret
        
._4     xor     a`zero
        ld      [ix+#mob.Xspeed+0],a`zero
        ld      [ix+#mob.Xspeed+1],a`zero
        ld      [ix+#mob.Xdirection],a`zero
        ld      [ix+#mob.Yspeed+0],a`zero
        ld      [ix+#mob.Yspeed+1],a`zero
        ld      [ix+#mob.Ydirection],a`zero
        
        ld      de,$0024
        ld      hl,[$.D216]
        bit     1,[ix+#mob.flags]
        jr      z,._5
        ld      de,$0036
._5     add     hl,de
        ld      de,._7922
        add     hl,de
        ld      [ix+#mob.spriteLayout+0],l
        ld      [ix+#mob.spriteLayout+1],h
        ld      hl,$.D2ED+1                     ;lo-addr of $.D2ED
        ld      a,[hl]
        cp      $0a
        jp      nc,._6
        dec     hl
        dec     [hl]
        ret     nz
        ld      [hl],$18
        inc     hl
        inc     [hl]
        call    :_7a3a
        ret
        
._6     ld      a,[$.D2ED+1]                    ;lo-addr of $.D2ED
        cp      $3a
        jr      nc,._7
        ld      l,[ix+#mob.Ysubpixel]
        ld      h,[ix+#mob.Y+0]
        ld      a,[ix+#mob.Y+1]
        ld      de,$0020
        add     hl,de
        adc     a,$00
        ld      [ix+#mob.Ysubpixel],l
        ld      [ix+#mob.Y+0],h
        ld      [ix+#mob.Y+1],a
._7     ld      hl,$.D2ED+1                     ;lo-addr of $.D2ED
        ld      a,[hl]
        cp      $5a
        jr      nc,._8
        inc     [hl]
        ret
        
._8     jr      nz,._9
        ld      [hl],$5b
        
        ld      a,[$.LEVEL_MUSIC]
        rst     :rst_playMusic
        
        ld      a,[iy+#vars.spriteUpdateCount]
        res     0,[iy+#vars.flags0]
        call    ::interrupts:waitForInterrupt
        ld      [iy+#vars.spriteUpdateCount],a
._9     ld      [ix+#mob.Xspeed+0],$00
        ld      [ix+#mob.Xspeed+1],$03
        ld      [ix+#mob.Xdirection],$00
        ld      [ix+#mob.Yspeed+0],$60
        ld      [ix+#mob.Yspeed+1],$ff
        ld      [ix+#mob.Ydirection],$ff
        ld      [ix+#mob.spriteLayout+0],LO ._7922
        ld      [ix+#mob.spriteLayout+1],HI ._7922
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      de,[$.CAMERA_X]
        inc     d
        and     a
        sbc     hl,de
        ret     c
        
        ;unlocks the screen?
        ld      [ix+#mob.type],$FF              ;remove mob?
        ld      hl,$2000                        ;8192 -- max width of a level in pixels
        ld      [$.LEVEL_RIGHT],hl
        ld      hl,$0000
        ld      [$.CAMERA_X_GOTO],hl
        
        set     5,[iy+#vars.flags0]
        set     0,[iy+#vars.flags2]
        res     1,[iy+#vars.flags2]
        
        ld      a,[$.CURRENT_LEVEL]
        cp      $0b
        jr      nz,._10
        
        set     1,[iy+#vars.flags9]
        
._10    ;UNKNOWN
        ld      hl,$DA28
        ld      de,$2000
        ld      a,12
        call    ::main:decompressArt
        ret

;sprite layout
._7922  BYTE    $2A, $2C, $2E, $30, $32, $FF
        BYTE    $4A, $4C, $4E, $50, $52, $FF
        BYTE    $6A, $6C, $6E, $70, $72, $FF
            
        BYTE    $20, $10, $12, $14, $28, $FF
        BYTE    $40, $42, $44, $46, $48, $FF
        BYTE    $60, $62, $64, $66, $68, $FF
            
        BYTE    $2A, $16, $18, $1A, $32, $FF
        BYTE    $4A, $4C, $4E, $50, $52, $FF
        BYTE    $6A, $6C, $6E, $70, $72, $FF
            
        BYTE    $20, $3A, $3C, $3E, $28, $FF
        BYTE    $40, $42, $44, $46, $48, $FF
        BYTE    $60, $62, $64, $66, $68, $FF
            
        BYTE    $2A, $34, $36, $38, $32, $FF
        BYTE    $4A, $4C, $4E, $50, $52, $FF
        BYTE    $6A, $6C, $6E, $70, $72, $FF
            
        BYTE    $20, $10, $12, $14, $28, $FF
        BYTE    $40, $42, $44, $46, $48, $FF
        BYTE    $60, $54, $56, $66, $68, $FF
            
        BYTE    $2A, $16, $18, $1A, $32, $FF
        BYTE    $4A, $4C, $4E, $50, $52, $FF
        BYTE    $6A, $5A, $5C, $70, $72, $FF
            
        BYTE    $20, $3A, $3C, $3E, $28, $FF
        BYTE    $40, $42, $44, $46, $48, $FF
        BYTE    $60, $54, $56, $66, $68, $FF
            
        BYTE    $2A, $34, $36, $38, $32, $FF
        BYTE    $4A, $4C, $4E, $50, $52, $FF
        BYTE    $6A, $5A, $5C, $70, $72, $FF
            
        BYTE    $20, $06, $08, $0A, $28, $FF
        BYTE    $40, $42, $44, $46, $48, $FF
        BYTE    $60, $62, $64, $66, $68, $FF
            
        BYTE    $20, $06, $08, $0A, $28, $FF
        BYTE    $40, $42, $44, $46, $48, $FF
        BYTE    $60, $62, $64, $66, $68, $FF
            
        BYTE    $0E, $10, $12, $14, $16, $FF
        BYTE    $40, $42, $44, $46, $48, $FF
        BYTE    $60, $62, $64, $66, $68, $FF
}

PROC    :_79fa                                  SECTION ::mobs                  ;$79FA
        ;===============================================================================
        ;called by green hill boss, jungle boss and final animation
        
PARAMS  IX`mob          ``Address of the current mob being processed
{
        ld      a,[ix+#mob.Xspeed+0]
        or      [ix+#mob.Xspeed+1]
        ret     z
        ld      a,[$.FRAMECOUNT]
        bit     0,a
        ret     nz
        and     $02
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      [$.TEMP1],hl
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      [$.TEMP3],hl
        ld      hl,$fff8
        ld      de,$0010
        ld      c,$04
        bit     7,[ix+#mob.Xdirection]
        jr      z,._1
        ld      hl,$0028
        ld      c,$00
._1     ld      [$.TEMP4],hl
        ld      [$.TEMP6],de
        add     a,c
        call    :_3581
        ret
}

PROC    :_7a3a                                  SECTION ::mobs                  ;$7A3A
        ;===============================================================================
        ;called by `:_77be`, capsule and final animation
        
PARAMS  IX`mob          ``Address of the current mob being processed
{
        call    :findEmptyMob
        ret     c
        push    hl
        call    ::main:_LABEL_625_57
        and     $1f
        ld      l,a
        ld      h,$00
        ld      [$.TEMP1],hl
        call    ::main:_LABEL_625_57
        and     $1f
        ld      l,a
        ld      h,$00
        ld      [$.TEMP3],hl
        pop     hl
        ld      e,[ix+#mob.X+0]
        ld      d,[ix+#mob.X+1]
        ld      c,[ix+#mob.Y+0]
        ld      b,[ix+#mob.Y+1]
        push    ix
        push    hl
        pop     ix
        xor     a`zero                          ;set A to 0
        ld      [ix+#mob.type],$0A              ;explosion
        ld      [ix+#mob.Xsubpixel],a`zero
        ld      hl,[$.TEMP1]
        add     hl,de
        ld      [ix+#mob.X+0],l
        ld      [ix+#mob.X+1],h
        ld      [ix+#mob.Ysubpixel],a`zero
        ld      hl,[$.TEMP3]
        add     hl,bc
        ld      [ix+#mob.Y+0],l
        ld      [ix+#mob.Y+1],h
        ld      [ix+#mob.unknown11],a`zero
        ld      [ix+#mob.unknown16],a`zero
        ld      [ix+#mob.unknown17],a`zero
        ld      [ix+#mob.Xspeed+0],a`zero
        ld      [ix+#mob.Xspeed+1],a`zero
        ld      [ix+#mob.Xdirection],a`zero
        ld      [ix+#mob.Yspeed+0],a`zero
        ld      [ix+#mob.Yspeed+1],a`zero
        ld      [ix+#mob.Ydirection],a`zero
        
        pop     ix
        ld      a,$01
        rst     :rst_playSFX
        ret
}

INCLUDE "mobs\meta_trip.oz80"
INCLUDE "mobs\flower.oz80"
INCLUDE "mobs\meta_blink.oz80"

PROC    :_7c41                                  SECTION ::mobs                  ;$7C41
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
        de              ;e.g. $7DE1
        bc              ;e.g. $7DDC
{
        ld      l,[ix+#mob.unknown17]

._1     ld      h,$00
        add     hl,bc
        ld      a,[hl]
        cp      $ff
        jr      nz,._2
        ld      l,$00
        ld      [ix+#mob.unknown17],l
        jp      ._1
        
._2     inc     hl
        push    hl
        ld      l,a
        ld      h,$00
        add     hl,hl
        ld      c,l
        ld      b,h
        add     hl,hl
        add     hl,hl
        add     hl,hl
        add     hl,bc
        add     hl,de
        ld      [ix+#mob.spriteLayout+0],l
        ld      [ix+#mob.spriteLayout+1],h
        pop     hl
        inc     [ix+#mob.unknown16]
        ld      a,[hl]
        cp      [ix+#mob.unknown16]
        ret     nc
        ld      [ix+#mob.unknown16],$00
        inc     [ix+#mob.unknown17]
        inc     [ix+#mob.unknown17]
        ret
}       

PROC    :findEmptyMob                           SECTION ::mobs                  ;$7C7B
        ;===============================================================================
HELP ```search through the mob storage and find the first empty mob available
        (this is used when spawning new mobs, such as bullets)
        ```
RETURN  AF              ``carry is set if no mob was found
        B               ``mob slot index number (0-31)
        HL              ``address of the empty mob slot selected
{
        ld      hl,$.MOBS
        ld      de,#mob.size
        ld      b, 31                           ;number of mob slots, less Sonic?
        
.loop   ld      a,[hl]
        cp      $FF                             ;"No Mob" number
        ret     z                               ;if = $FF then exit, empty slot found
        add     hl,de
        djnz    .loop
        
        ;no free mob place found!
        scf                                     ;set the carry as a return flag
        ret
}

PROC    :_7c8c                                  SECTION ::mobs                  ;$7C8C
        ;===============================================================================
        ;used by bosses to lock the screen?
        
PARAMS  hl, de
{
        ld      [$.CAMERA_X_GOTO],hl
        ld      [$.CAMERA_Y_GOTO],de
        
        ld      hl,[$.CAMERA_X]
        ld      [$.LEVEL_LEFT],hl
        ld      [$.LEVEL_RIGHT],hl
        
        ld      hl,[$.CAMERA_Y]
        ld      [$.LEVEL_TOP],hl
        ld      [$.LEVEL_BOTTOM],hl
        ret
}

PROC    :_7ca6                                  SECTION ::mobs                  ;$7CA6
        ;===============================================================================
{
        ld      hl,[$.CAMERA_X_GOTO]
        ld      de,[$.CAMERA_X]
        and     a
        sbc     hl,de
        ret     nz
        ld      hl,[$.CAMERA_Y_GOTO]
        ld      de,[$.CAMERA_Y]
        and     a
        sbc     hl,de
        ret     nz
        res     5,[iy+#vars.flags0]
        ret
}

PROC    :_LABEL_7CC1_12                         SECTION ::mobs                  ;$7CC1
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
        D               ;bit 7 sets A to $FF instead of 0 -- direction?
{
        bit     6, [iy+#vars.flags6]
        ret     nz
        
        ld      l, [ix+#mob.Ysubpixel]
        ld      h, [ix+#mob.Y+0]
        
        xor     a`zero                          ;set A to 0
        
        bit     7, d
        jr      z, ._1
        dec     a
._1     add     hl, de
        adc     a, [ix+#mob.Y+1]
        ld      l, h
        ld      h, a
        add     hl, bc
        ld      a, [$.SONIC.height]
        ld      c, a
        xor     a`zero
        ld      b, a`zero
        sbc     hl, bc
        ld      [$.SONIC.Y], hl
        ld      a, [$.D2E8]
        ld      hl, [$.D2E6]
        ld      [$.SONIC.Yspeed], hl
        ld      [$.SONIC.Ydirection], a
        
        ld      hl, $.SONIC.flags
        set     7, [hl]
        
        ret
}

INCLUDE "mobs\badnick_chopper.oz80"

PROC    :mob_platform_fallVert                  SECTION ::mobs                  ;$7E02
        ;===============================================================================
        ;log - vertical (Jungle)
        
PARAMS  IX`mob          ``Address of the current mob being processed
{
        set     5,[ix+#mob.flags]               ;mob does not collide with the floor
        ld      hl,$0030
        ld      [$.D267],hl
        ld      hl,$0058
        ld      [$.D269],hl
        ld      [ix+#mob.width],$0c
        ld      [ix+#mob.height],$10
        ld      [ix+#mob.spriteLayout+0],LO ._7e89
        ld      [ix+#mob.spriteLayout+1],HI ._7e89
        bit     0,[ix+#mob.flags]
        jr      nz,._7e3c
        ld      a,[ix+#mob.Y+0]
        ld      [ix+$12],a
        ld      a,[ix+#mob.Y+1]
        ld      [ix+#mob.unknown13],a
        ld      [ix+#mob.unknown14],$c0
        set     0,[ix+#mob.flags]
._7e3c
        ld      [ix+#mob.Yspeed+0],$80
        xor     a`zero
        ld      [ix+#mob.Yspeed+1], a`zero
        ld      [ix+#mob.Ydirection], a`zero
        
        ld      a, [$.SONIC.Ydirection]
        and     a
        jp      m, ._1
        
        ld      hl, $0806
        ld      [$.TEMP6], hl
        call    :detectCollisionWithSonic
        jr      c, ._1
        ld      bc, $0010
        ld      e, [ix+#mob.Yspeed+0]
        ld      d, [ix+#mob.Yspeed+1]
        call    :_LABEL_7CC1_12
._1     ld      a, [$.FRAMECOUNT]
        and     $03
        ret     nz
        inc     [ix+#mob.unknown11]
        ld      a, [ix+#mob.unknown11]
        cp      [ix+#mob.unknown14]
        ret     c
        xor     a`zero                          ;set A to 0
        ld      [ix+#mob.unknown11], a`zero
        ld      [ix+#mob.Ysubpixel], a`zero
        ld      a, [ix+$12]
        ld      [ix+#mob.Y+0], a
        ld      a, [ix+#mob.unknown13]
        ld      [ix+#mob.Y+1], a
        ret

        ;sprite layout
._7e89  BYTE $FE, $FF, $FF, $FF, $FF, $FF
        BYTE $18, $1A, $FF, $FF, $FF, $FF
        BYTE $28, $2E, $FF, $FF, $FF, $FF
}

PROC    :mob_platform_fallHoriz                 SECTION ::mobs                  ;$7E9B
        ;===============================================================================
        ;log - horizontal (Jungle)
        
PARAMS  IX`mob          ``Address of the current mob being processed
{
        set     5,[ix+#mob.flags]               ;mob does not collide with the floor
        ld      hl,$0030
        ld      [$.D267],hl
        ld      hl,$0058
        ld      [$.D269],hl
        ld      [ix+#mob.width],$1a
        ld      [ix+#mob.height],$10
        ld      [ix+#mob.spriteLayout+0],LO .layout
        ld      [ix+#mob.spriteLayout+1],HI .layout
        bit     0,[ix+#mob.flags]
        jp      nz,:mob_platform_fallVert._7e3c
        ld      a,[ix+#mob.Y+0]
        ld      [ix+$12],a
        ld      a,[ix+#mob.Y+1]
        ld      [ix+#mob.unknown13],a
        ld      [ix+#mob.unknown14],$c6
        set     0,[ix+#mob.flags]
        jp      :mob_platform_fallVert._7e3c
        
        ;sprite layout
.layout BYTE $FE, $FF, $FF, $FF, $FF, $FF                                       ;$7ED9
        BYTE $6C, $6E, $6E, $48, $FF, $FF
        BYTE $FF
}

PROC    :mob_platform_roll                      SECTION ::mobs                  ;$7EE6
        ;===============================================================================
        ;log - floating (Jungle)
        
PARAMS  IX`mob          ``Address of the current mob being processed
{
        set     5,[ix+#mob.flags]               ;mob does not collide with the floor
        ld      [ix+#mob.width],$0a
        ld      [ix+#mob.height],$10
        bit     0,[ix+#mob.flags]
        jr      nz,._1
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      de,$ffe8
        add     hl,de
        ld      [ix+#mob.Y+0],l
        ld      [ix+#mob.Y+1],h
        set     0,[ix+#mob.flags]
._1     ld      [ix+#mob.Yspeed+0],$40
        xor     a`zero
        ld      [ix+#mob.Yspeed+1],a`zero
        ld      [ix+#mob.Ydirection],a`zero
        ld      a,[ix+#mob.unknown11]
        cp      $14
        jr      c,._2
        ld      [ix+#mob.Yspeed+0],$c0
        ld      [ix+#mob.Yspeed+1],$ff
        ld      [ix+#mob.Ydirection],$ff
        
._2     ld      a,[$.SONIC.Ydirection]
        and     a
        jp      m,._8003
        
        ld      hl,$0806
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        jp      c,._8003
        ld      bc,$0010
        ld      e,[ix+#mob.Yspeed+0]
        ld      d,[ix+#mob.Yspeed+1]
        call    :_LABEL_7CC1_12
        ld      hl,[$.SONIC.Xspeed]
        ld      a,l
        or      h
        jr      z,._4
        ld      bc,$0012
        bit     7,h
        jr      z,._3
        ld      bc,$fffe
._3     ld      de,$0000
        call    :getFloorLayoutRAMAddressForMob
        ld      e,[hl]
        ld      d,$00
        ld      a,[$.LEVEL_SOLIDITY]
        add     a,a
        ld      c,a
        ld      b,d
        ld      hl,:S1_Solidity_Blocks
        add     hl,bc
        ld      a,[hl]
        inc     hl
        ld      h,[hl]
        ld      l,a
        add     hl,de
        ld      a,[hl]
        and     $3f
        ld      a,d
        ld      e,d
        jr      nz,._5
._4     ld      a,[$.SONIC.Xspeed+0]
        ld      de,[$.SONIC.Xspeed+1]
        sra     d
        rr      e
        rra     
._5     ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        add     a,[ix+#mob.Xsubpixel]
        adc     hl,de
        ld      [ix+#mob.Xsubpixel],a
        ld      [ix+#mob.X+0],l
        ld      [ix+#mob.X+1],h
        ld      [$.SONIC.Xsubpixel],a
        ld      de,$fffc
        add     hl,de
        ld      [$.SONIC.X],hl
        ld      de,[$.SONIC.Xspeed]
        bit     7,d
        jr      z,._6
        ld      a,e
        cpl     
        ld      e,a
        ld      a,d
        cpl     
        ld      d,a
        inc     de
._6     ld      l,[ix+$12]
        ld      h,[ix+#mob.unknown13]
        add     hl,de
        ld      a,h
        cp      $09
        jr      c,._7
        sub     $09
        ld      h,a
._7     ld      [ix+$12],l
        ld      [ix+#mob.unknown13],h
        ld      e,a
        ld      d,$00
        ld      hl,._8019
        add     hl,de
        ld      e,[hl]
        ld      hl,._8022
        add     hl,de
        ld      [ix+#mob.spriteLayout+0],l
        ld      [ix+#mob.spriteLayout+1],h
        jr      ._800b

;=======================================================================================

        ;ROM Header:
        
        BYTE $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE $00 $0, $00 $00 $00
        
        BYTE "TMR SEGA"
        
        BYTE $59, $59
        BYTE $1B, $A5
        BYTE $76, $70, $00
        BYTE $40

;=======================================================================================
        
        BYTE $00, $00, $00

        ;jumped to by `doObjectCode_platform_roll`, OBJECT: log - floating (Jungle)
._8003  ld      [ix+#mob.spriteLayout+0], LO ._8022
        ld      [ix+#mob.spriteLayout+1], HI ._8022
._800b  inc     [ix+#mob.unknown11]
        ld      a,[ix+#mob.unknown11]
        cp      $28
        ret     c
        ld      [ix+#mob.unknown11],$00
        ret

._8019  BYTE $00, $00, $00, $12, $12, $12, $24, $24, $24

        ;sprite layout
._8022  BYTE $FE, $FF, $FF, $FF, $FF, $FF
        BYTE $3A, $3C, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $FE, $FF, $FF, $FF, $FF, $FF
        BYTE $36, $38, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $FE, $FF, $FF, $FF, $FF, $FF
        BYTE $4C, $4E, $FF, $FF, $FF, $FF
        BYTE $FF
}

INCLUDE "mobs\boss_jungle.oz80"
INCLUDE "mobs\unknown_8128.oz80"
INCLUDE "mobs\badnick_yadrin.oz80"
INCLUDE "mobs\platform_bridge.oz80"

PROC    :mob_boss_bridge                        SECTION ::mobs                  ;$8496
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        set     5,[ix+#mob.flags]               ;mob does not collide with the floor
        ld      [ix+#mob.width], 30
        ld      [ix+#mob.height],28
        call    :_7ca6
        ld      [ix+#mob.spriteLayout+0],LO :_865a
        ld      [ix+#mob.spriteLayout+1],HI :_865a
        bit     0,[ix+#mob.flags]
        jr      nz,._1
        
        ld      hl,$03a0
        ld      de,$0300
        call    :_7c8c
        
        ;UNKNOWN
        ld      hl,$e508
        ld      de,$2000
        ld      a,12
        call    ::main:decompressArt
        
        ld      hl,:S1_BossPalette
        ld      a,%00000010
        call    ::interrupts:loadPaletteOnInterrupt
        xor     a`zero
        ld      [$.D2EC],a`zero
        
        ld      a,::sound:S1_MusicPointers.boss1.index ;=$0B
        rst     :rst_playMusic
        
        set     0,[ix+#mob.flags]
._1     ld      a,[ix+#mob.unknown11]
        and     a
        jr      nz,._2
        call    ::main:_LABEL_625_57
        and     $01
        add     a,a
        add     a,a
        ld      e,a
        ld      d,$00
        ld      hl,:_8632
        add     hl,de
        ld      a,[hl]
        ld      [ix+#mob.X+0],a
        inc     hl
        ld      a,[hl]
        inc     hl
        ld      [ix+#mob.X+1],a
        ld      a,[hl]
        inc     hl
        ld      [ix+#mob.Y+0],a
        ld      a,[hl]
        inc     hl
        ld      [ix+#mob.Y+1],a
        inc     [ix+#mob.unknown11]
        jp      ._6
        
._2     dec     a
        jr      nz,._3
        ld      [ix+#mob.Yspeed+0],$80
        ld      [ix+#mob.Yspeed+1],$ff
        ld      [ix+#mob.Ydirection],$ff
        ld      hl,$0380
        ld      e,[ix+#mob.Y+0]
        ld      d,[ix+#mob.Y+1]
        xor     a`zero
        sbc     hl,de
        jp      c,._6
        inc     [ix+#mob.unknown11]
        ld      [ix+$12],a`zero
        jp      ._6
        
._3     dec     a
        jr      nz,._5
        xor     a`zero
        ld      [ix+#mob.Yspeed+0],a`zero
        ld      [ix+#mob.Yspeed+1],a`zero
        ld      [ix+#mob.Ydirection],a`zero
        inc     [ix+$12]
        ld      a,[ix+$12]
        cp      $64
        jp      nz,._6
        inc     [ix+#mob.unknown11]
        ld      a,[$.D2EC]
        cp      $08
        jr      nc,._6
        ld      hl,[$.SONIC.X]
        ld      e,[ix+#mob.X+0]
        ld      d,[ix+#mob.X+1]
        and     a
        sbc     hl,de
        ld      hl,:_863a
        jr      c,._4
        ld      hl,:_864a
._4     ld      e,[hl]
        inc     hl
        ld      d,[hl]
        inc     hl
        ld      c,[hl]
        inc     hl
        ld      b,[hl]
        inc     hl
        push    hl
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        add     hl,de
        ld      [$.TEMP1],hl
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        add     hl,bc
        ld      [$.TEMP3],hl
        pop     hl
        ld      b,$03
        
.loop   push    bc
        ld      a,[hl]
        ld      [$.TEMP4],a
        inc     hl
        ld      a,[hl]
        ld      [$.TEMP5],a
        inc     hl
        ld      a,[hl]
        ld      [$.TEMP6],a
        inc     hl
        ld      a,[hl]
        ld      [$.TEMP7],a
        inc     hl
        push    hl
        ld      c,$10
        call    :_85d1
        pop     hl
        pop     bc
        djnz    .loop
        
        ld      a,$01
        rst     :rst_playSFX
        jp      ._6
        
._5     ld      [ix+#mob.Yspeed+0],$80
        ld      [ix+#mob.Yspeed+1],$00
        ld      [ix+#mob.Ydirection],$00
        ld      hl,$03c0
        ld      e,[ix+#mob.Y+0]
        ld      d,[ix+#mob.Y+1]
        xor     a`zero
        sbc     hl,de
        jr      nc,._6
        ld      [ix+#mob.unknown11],a`zero
        
._6     ld      hl,$00a2
        ld      [$.D216],hl
        call    :_77be
        ret
}

PROC    :_85d1                                  SECTION ::mobs                  ;$85D1
        ;===============================================================================
        ;called by bridge & labyrinth boss
        
PARAMS  IX`mob          ``Address of the current mob being processed
{
        push    bc
        call    :findEmptyMob
        pop     bc
        ret     c
        push    ix
        push    hl
        pop     ix
        xor     a`zero                          ;set A to 0
        ld      [ix+#mob.type],$0D              ;unknown mob
        ld      hl,[$.TEMP1]
        ld      [ix+#mob.Xsubpixel],a`zero
        ld      [ix+#mob.X+0],l
        ld      [ix+#mob.X+1],h
        ld      hl,[$.TEMP3]
        ld      [ix+#mob.Ysubpixel],a`zero
        ld      [ix+#mob.Y+0],l
        ld      [ix+#mob.Y+1],h
        ld      [ix+#mob.unknown11],a`zero
        ld      [ix+#mob.unknown13],c
        ld      [ix+#mob.unknown14],a`zero
        ld      [ix+#mob.unknown15],a`zero
        ld      [ix+#mob.unknown16],a`zero
        ld      [ix+#mob.unknown17],a`zero
        ld      hl,[$.TEMP4]
        xor     a`zero
        bit     7,h
        jr      z,._1
        dec     a
._1     ld      [ix+#mob.Xspeed+0],l
        ld      [ix+#mob.Xspeed+1],h
        ld      [ix+#mob.Xdirection],a
        ld      hl,[$.TEMP6]
        xor     a
        bit     7,h
        jr      z,._2
        dec     a
._2     ld      [ix+#mob.Yspeed+0],l
        ld      [ix+#mob.Yspeed+1],h
        ld      [ix+#mob.Ydirection],a
        pop     ix
        ret
}

TABLE   :_8632                                  SECTION ::mobs                  ;$8632
{
        BYTE $D4 $03 $C0 $03 $44 $04 $C0 $03
}
TABLE   :_863a                                  SECTION ::mobs                  ;$863A
{
        BYTE $00 $00 $F6 $FF $C0 $FE $00 $FC $60 $FE $80 $FD $C0 $FD $00 $FF
}
TABLE   :_864a                                  SECTION ::mobs                  ;$864A
{
        BYTE $20 $00 $F6 $FF $40 $01 $00 $FC $A0 $01 $80 $FD $40 $02 $00 $FF
}

;sprite layout
TABLE   :_865a                                  SECTION ::mobs                  ;$865A
{
        BYTE $20, $22, $24, $26, $28, $FF
        BYTE $40, $42, $44, $46, $48, $FF
        BYTE $60, $62, $64, $66, $68, $FF
}

INCLUDE "mobs\platform_balance.oz80"
INCLUDE "mobs\badnick_jaws.oz80"
INCLUDE "mobs\trap_spikeball.oz80"
INCLUDE "mobs\trap_spear.oz80"
INCLUDE "mobs\trap_fireball.oz80"
INCLUDE "mobs\meta_water.oz80"
INCLUDE "mobs\powerup_bubbles.oz80"

PROC    :_8eca                                  SECTION ::mobs                  ;$8ECA
        ;===============================================================================
        ;unknown mob
        
PARAMS  IX`mob          ``Address of the current mob being processed
{
        set     5, [ix+#mob.flags]
        xor     a`zero
        ld      [ix+#mob.spriteLayout+0],a`zero
        ld      [ix+#mob.spriteLayout+1],a`zero
        ld      a,[ix+#mob.unknown11]
        and     $0f
        jr      nz,._2
        call    ::main:_LABEL_625_57
        ld      bc,$0020
        ld      d,$00
        and     $3f
        cp      $20
        jr      c,._1
        ld      bc,$ffe0
        ld      d,$ff
._1     ld      [ix+#mob.Xspeed+0],c
        ld      [ix+#mob.Xspeed+1],b
        ld      [ix+#mob.Xdirection],d
._2     ld      [ix+#mob.Yspeed+0],$a0
        ld      [ix+#mob.Yspeed+1],$ff
        ld      [ix+#mob.Ydirection],$ff
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      [$.TEMP1],hl
        ex      de,hl
        ld      hl,[$.CAMERA_X]
        ld      bc,$0008
        xor     a`zero
        sbc     hl,bc
        jr      nc,._3
        ld      l,a`zero
        ld      h,a`zero
._3     and     a
        sbc     hl,de
        jr      nc,._4
        ld      hl,[$.CAMERA_X]
        ld      bc,$0100
        add     hl,bc
        and     a
        sbc     hl,de
        jr      c,._4
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      [$.TEMP3],hl
        ex      de,hl
        ld      hl,[$.D2DC]
        and     a
        sbc     hl,de
        jr      nc,._4
        ld      hl,[$.CAMERA_Y]
        ld      bc,$fff0
        add     hl,bc
        and     a
        sbc     hl,de
        jr      nc,._4
        ld      hl,[$.CAMERA_Y]
        ld      bc,$00c0
        add     hl,bc
        and     a
        sbc     hl,de
        jr      nc,._5
._4     ld      [ix+#mob.type],$FF              ;remove mob?
._5     ld      hl,$0000
        ld      [$.TEMP4],hl
        ld      [$.TEMP6],hl
        ld      a,$0c
        call    :_3581
        inc     [ix+#mob.unknown11]
        ret
}

INCLUDE "mobs\null.oz80"
INCLUDE "mobs\badnick_burrobot.oz80"
INCLUDE "mobs\platform_float.oz80"

PROC    :_91eb                                  SECTION ::mobs                  ;$91EB
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        call    :findEmptyMob
        ret     c
        ld      c,$42
        ld      a,[ix+#mob.type]
        cp      $41
        jr      nz,._1
        push    hl
        call    ::main:_LABEL_625_57
        and     $0f
        ld      e,a
        ld      d,$00
        ld      hl,._9257
        add     hl,de
        ld      c,[hl]
        pop     hl
._1     ld      a,c
        ld      e,[ix+#mob.X+0]
        ld      d,[ix+#mob.X+1]
        ld      c,[ix+#mob.Y+0]
        ld      b,[ix+#mob.Y+1]
        push    ix
        push    hl
        pop     ix
        ld      [ix+#mob.type],a
        xor     a`zero                          ;set A to 0
        ld      [ix+#mob.Xsubpixel],a`zero
        call    ::main:_LABEL_625_57
        and     $0f
        ld      l,a
        ld      h,$00
        add     hl,de
        ld      [ix+#mob.X+0],l
        ld      [ix+#mob.X+1],h
        ld      [ix+#mob.Ysubpixel],$00
        call    ::main:_LABEL_625_57
        and     $0f
        ld      l,a
        xor     a`zero
        ld      h,a`zero
        add     hl,bc
        ld      [ix+#mob.Y+0],l
        ld      [ix+#mob.Y+1],h
        ld      [ix+#mob.unknown11],a`zero
        ld      [ix+$12],a`zero
        ld      [ix+#mob.flags],a`zero
        ld      [ix+#mob.Xspeed+0],a`zero
        ld      [ix+#mob.Xspeed+1],a`zero
        ld      [ix+#mob.Xdirection],a`zero
        pop     ix
        ret

._9257  BYTE $42 $20 $20 $20 $42 $20 $20 $20 $42 $20 $20 $20 $42 $20 $20 $20

}

PROC    :mob_boss_labyrinth                     SECTION ::mobs                  ;$9267
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        set     5, [ix+#mob.flags]
        ld      [ix+#mob.width],  32
        ld      [ix+#mob.height], 28
        call    :_7ca6
        ld      [ix+#mob.spriteLayout+0],LO ._9493
        ld      [ix+#mob.spriteLayout+1],HI ._9493
        bit     0,[ix+#mob.flags]
        jr      nz,._1
        
        ld      hl,$02d0
        ld      de,$0290
        call    :_7c8c
        
        set     1,[iy+#vars.flags9]
        
        ;UNKNOWN
        ld      hl,$e508
        ld      de,$2000
        ld      a,12
        call    ::main:decompressArt
        
        ld      hl,:S1_BossPalette
        ld      a,%00000010
        call    ::interrupts:loadPaletteOnInterrupt
        xor     a`zero
        ld      [$.D2EC],a`zero
        
        ld      a,::sound:S1_MusicPointers.boss1.index ;=$0B
        rst     :rst_playMusic
        
        set     0,[ix+#mob.flags]
._1     ld      a,[ix+#mob.unknown11]
        and     a
        jr      nz,._2
        ld      a,[ix+#mob.unknown13]
        add     a,a
        add     a,a
        ld      e,a
        ld      d,$00
        ld      hl,._947b
        add     hl,de
        ld      a,[hl]
        ld      [ix+#mob.X+0],a
        inc     hl
        ld      a,[hl]
        inc     hl
        ld      [ix+#mob.X+1],a
        ld      a,[hl]
        inc     hl
        ld      [ix+#mob.Y+0],a
        ld      a,[hl]
        inc     hl
        ld      [ix+#mob.Y+1],a
        inc     [ix+#mob.unknown11]
        jp      ._
        
._2     dec     a
        jr      nz,._5
        ld      a,[ix+#mob.unknown13]
        and     a
        jr      nz,._3
        ld      [ix+#mob.Yspeed+0],$80
        ld      [ix+#mob.Yspeed+1],$ff
        ld      [ix+#mob.Ydirection],$ff
        jp      ._4
        
._3     ld      [ix+#mob.Yspeed+0],$80
        ld      [ix+#mob.Yspeed+1],$00
        ld      [ix+#mob.Ydirection],$00
._4     ld      hl,._9487
        ld      a,[ix+#mob.unknown13]
        add     a,a
        ld      e,a
        ld      d,$00
        add     hl,de
        ld      a,[hl]
        inc     hl
        ld      h,[hl]
        ld      l,a
        ld      e,[ix+#mob.Y+0]
        ld      d,[ix+#mob.Y+1]
        and     a
        sbc     hl,de
        jp      nz,._
        inc     [ix+#mob.unknown11]
        ld      [ix+$12],$00
        jp      ._
        
._5     dec     a
        jp      nz,._6
        xor     a`zero
        ld      [ix+#mob.Yspeed+0],a`zero
        ld      [ix+#mob.Yspeed+1],a`zero
        ld      [ix+#mob.Ydirection],a`zero
        inc     [ix+$12]
        ld      a,[ix+$12]
        cp      $64
        jp      nz,._
        inc     [ix+#mob.unknown11]
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      de,$000f
        add     hl,de
        ld      [$.TEMP1],hl
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      bc,$0022
        add     hl,bc
        ld      [$.TEMP3],hl
        ld      a,[ix+#mob.unknown13]
        and     a
        jp      z,._9432
        ld      a,[$.D2EC]
        cp      $08
        jp      nc,._
        call    :findEmptyMob
        jp      c,._
        
        push    ix
        push    hl
        pop     ix
        
        xor     a`zero                          ;set A to 0
        ld      [ix+#mob.type],$2F              ;unknown mob
        ld      hl,[$.TEMP1]
        ld      [ix+#mob.Xsubpixel]     a`zero
        ld      [ix+#mob.X+0]           l
        ld      [ix+#mob.X+1]           h
        ld      hl,[$.TEMP3]
        ld      [ix+#mob.Ysubpixel]     a`zero
        ld      [ix+#mob.Y+0]           l
        ld      [ix+#mob.Y+1]           h
        ld      [ix+#mob.flags]         a`zero
        ld      [ix+#mob.Xspeed+0]      a`zero
        ld      [ix+#mob.Xspeed+1]      a`zero
        ld      [ix+#mob.Xdirection]    a`zero
        ld      [ix+#mob.Yspeed+0]      a`zero
        ld      [ix+#mob.Yspeed+1]      a`zero
        ld      [ix+#mob.Ydirection]    a`zero
        
        pop     ix
        jp      ._
        
        ;-------------------------------------------------------------------------------
        
._6     ld      a,[ix+#mob.unknown13]
        and     a
        jr      nz,._7
        ld      [ix+#mob.Yspeed+0],$80
        ld      [ix+#mob.Yspeed+1],$00
        ld      [ix+#mob.Ydirection],$00
        jp      ._8
        
._7     ld      [ix+#mob.Yspeed+0],$80
        ld      [ix+#mob.Yspeed+1],$ff
        ld      [ix+#mob.Ydirection],$ff
._8     ld      hl,$948d
        ld      a,[ix+#mob.unknown13]
        add     a,a
        ld      e,a
        ld      d,$00
        add     hl,de
        ld      a,[hl]
        inc     hl
        ld      h,[hl]
        ld      l,a
        ld      e,[ix+#mob.Y+0]
        ld      d,[ix+#mob.Y+1]
        xor     a`zero
        sbc     hl,de
        jr      nz,._
        ld      [ix+#mob.unknown11],a`zero
        inc     [ix+#mob.unknown13]
        ld      a,[ix+#mob.unknown13]
        cp      $03
        jr      c,._
        ld      [ix+#mob.unknown13],$00
._      ld      hl,$00a2
        ld      [$.D216],hl
        call    :_77be
        ld      a,[$.D2EC]
        cp      $08
        ret     nc
        bit     7,[ix+#mob.Ydirection]
        ret     z
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      [$.TEMP1],hl
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      [$.TEMP3],hl
        ld      hl,$0010
        ld      [$.TEMP4],hl
        ld      hl,$0030
        ld      [$.TEMP6],hl
        ld      a,[$.FRAMECOUNT]
        and     $02
        call    :_3581
        ret
        
._9432  ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      de,$0004
        add     hl,de
        ld      [$.TEMP1],hl
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      de,$fffa
        add     hl,de
        ld      [$.TEMP3],hl
        ld      hl,$ff00
        ld      [$.TEMP4],hl
        ld      hl,$ff00
        ld      [$.TEMP6],hl
        ld      c,$04
        call    :_85d1
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      de,$0020
        add     hl,de
        ld      [$.TEMP1],hl
        ld      hl,$0100
        ld      [$.TEMP4],hl
        ld      c,$04
        call    :_85d1
        ld      a,$01
        rst     :rst_playSFX
        jp      ._
        
._947b  BYTE $3C, $03, $60, $03, $EC, $02, $60, $02, $8C, $03, $60, $02
._9487  BYTE $28, $03, $B0, $02, $B0
._948c  BYTE $02, $60, $03, $60, $02, $60, $02

        ;sprite layout
._9493  BYTE $20, $22, $24, $26, $28, $FF
        BYTE $40, $42, $44, $46, $48, $FF
        BYTE $60, $62, $64, $66, $68, $FF
}

INCLUDE "mobs\unknown_94a5.oz80"
INCLUDE "mobs\unknown_96a8.oz80"
INCLUDE "mobs\unknown_96f8.oz80"
INCLUDE "mobs\platform_flipper.oz80"
INCLUDE "mobs\platform_bumper.oz80"
INCLUDE "mobs\unknown_9b75.oz80"
INCLUDE "mobs\unknown_9be8.oz80"

PROC    :_9c70                                  SECTION ::mobs                  ;$9C70
        ;===============================================================================
        ;unknown mob
        
PARAMS  IX`mob          ``Address of the current mob being processed
{
        ld      [ix+#mob.Xspeed+0],$80
        ld      [ix+#mob.Xspeed+1],$fe
        ld      [ix+#mob.Xdirection],$ff
        ld      [ix+#mob.spriteLayout+0], LO ._9c87
        ld      [ix+#mob.spriteLayout+1], HI ._9c87
        jp      :_9be8._9bfc

        ;sprite layout
._9c87  BYTE $2C, $2E, $FF, $FF, $FF, $FF
        BYTE $FF
}

PROC    :mob_trap_flameThrower                  SECTION ::mobs                  ;$9C8E
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        set     5,[ix+#mob.flags]               ;mob does not collide with the floor
        bit     0,[ix+#mob.flags]
        jr      nz,._1
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      de,$000c
        add     hl,de
        ld      [ix+#mob.X+0],l
        ld      [ix+#mob.X+1],h
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      de,$0012
        add     hl,de
        ld      [ix+#mob.Y+0],l
        ld      [ix+#mob.Y+1],h
        call    ::main:_LABEL_625_57
        ld      [ix+#mob.unknown11],a
        set     0,[ix+#mob.flags]
._1     ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      [$.TEMP1],hl
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      [$.TEMP3],hl
        ld      hl,$0000
        ld      [$.TEMP4],hl
        ld      a,[ix+#mob.unknown11]
        srl     a
        srl     a
        srl     a
        srl     a
        ld      c,a
        ld      b,$00
        add     a,a
        ld      e,a
        ld      d,$00
        ld      hl,:_9d6a
        add     hl,bc
        ld      a,[hl]
        ld      [ix+#mob.height],a
        ld      [ix+#mob.width],$06
        ld      hl,:_9d4a
        add     hl,de
        ld      a,[hl]
        inc     hl
        ld      h,[hl]
        ld      l,a
        or      h
        jr      z,._2
        ld      a,[ix+#mob.unknown11]
        add     a,a
        add     a,a
        add     a,a
        and     $1f
        ld      e,a
        ld      d,$00
        add     hl,de
        ld      b,$04
        
.loop   push    bc
        ld      a,[hl]
        inc     hl
        ld      e,[hl]
        inc     hl
        ld      d,$00
        push    hl
        ld      [$.TEMP6],de
        call    :_3581
        pop     hl
        pop     bc
        djnz    .loop
        
        ld      a,[ix+#mob.height]
        and     a
        jr      z,._2
        ld      hl,$0202
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        call    nc,:hitPlayer._35fd
._2     inc     [ix+#mob.unknown11]
        xor     a`zero
        ld      [ix+#mob.spriteLayout+0],a`zero
        ld      [ix+#mob.spriteLayout+1],a`zero
        ld      a,[ix+#mob.unknown11]
        cp      $70
        ret     nz
        ld      a,$17
        rst     :rst_playSFX
        ret
}

TABLE   :_9d4a                                  SECTION ::mobs                  ;$9D4A
{
        BYTE $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $9A $9D
        BYTE $BA $9D $DA $9D $7A $9D $7A $9D $7A $9D $DA $9D $BA $9D $9A $9D
}

TABLE   :_9d6a                                  SECTION ::mobs                  ;$9D6A
{
        BYTE $00 $00 $00 $00 $00 $00 $00 $1B $1F $22 $25 $25 $25 $22 $1F $1B
        BYTE $00 $15 $1E $0E $1E $07 $1E $00 $00 $17 $1E $10 $1E $09 $1E $02
        BYTE $00 $19 $1E $12 $1E $0B $1E $04 $00 $1B $1E $14 $1E $0D $1E $06
        BYTE $00 $0C $1E $08 $1E $04 $1E $00 $00 $0E $1E $0A $1E $06 $1E $02
        BYTE $00 $10 $1E $0C $1E $08 $1E $04 $00 $11 $1E $0E $1E $0A $1E $06
        BYTE $00 $0F $1E $0A $1E $05 $1E $00 $00 $11 $1E $0C $1E $07 $1E $02
        BYTE $00 $13 $1E $0E $1E $09 $1E $04 $00 $15 $1E $10 $1E $0B $1E $06
        BYTE $00 $12 $1E $0C $1E $06 $1E $00 $00 $14 $1E $0E $1E $08 $1E $02
        BYTE $00 $16 $1E $10 $1E $0A $1E $04 $00 $18 $1E $12 $1E $0C $1E $06
}

PROC    :mob_door_left                          SECTION ::mobs                  ;$9DFA
        ;===============================================================================
        ;door - one way left (Scrap Brain)
PARAMS  IX`mob          ``Address of the current mob being processed
{
        set     5,[ix+#mob.flags]               ;mob does not collide with the floor
        call    :_9ed4
        ld      a,[ix+#mob.unknown11]
        cp      $28
        jr      nc,._2
        ld      hl,$0005
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        jr      c,._2
        ld      de,$0005
        ld      a,[$.SONIC.Xdirection]
        and     a
        jp      m,._1
        ld      de,$ffec
._1     ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        add     hl,de
        ld      [$.SONIC.X],hl
        xor     a`zero
        ld      l`zero,a`zero
        ld      h`zero,a`zero
        ld      [$.SONIC.Xspeed],hl`zero
        ld      [$.SONIC.Xdirection],a`zero
._2     ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      de,$ffc8
        add     hl,de
        ld      de,[$.SONIC.X]
        xor     a`zero
        sbc     hl,de
        jr      nc,._3
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        and     a
        sbc     hl,de
        jr      c,._3
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      de,$ffe0
        add     hl,de
        ld      de,[$.SONIC.Y]
        xor     a`zero
        sbc     hl,de
        jr      nc,._3
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      bc,$0050
        add     hl,bc
        and     a
        sbc     hl,de
        jr      c,._3
        call    :_9eb4
        jr      ._4
        
._3     call    :_9ec4
._4     ld      de,:_9f2b
._9e7e  ld      a,[ix+#mob.unknown11]
        and     $0f
        ld      c,a
        ld      b,$00
        ld      l,[ix+$12]
        ld      h,[ix+#mob.unknown13]
        and     a
        sbc     hl,bc
        ld      [ix+#mob.Y+0],l
        ld      [ix+#mob.Y+1],h
        ld      a,[ix+#mob.unknown11]
        srl     a
        srl     a
        srl     a
        srl     a
        and     $03
        add     a,a
        ld      c,a
        add     a,a
        add     a,a
        add     a,a
        add     a,c
        ld      c,a
        ld      b,$00
        ex      de,hl
        add     hl,bc
        ld      [ix+#mob.spriteLayout+0],l
        ld      [ix+#mob.spriteLayout+1],h
        ret
}

PROC    :_9eb4                                  SECTION ::mobs                  ;$9EB4
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        ld      a,[ix+#mob.unknown11]
        cp      $30
        ret     nc
        inc     a
        ld      [ix+#mob.unknown11],a
        dec     a
        ret     nz
        ld      a,$19
        rst     :rst_playSFX
        ret
}

;____________________________________________________________________________[$9EC4]____

PROC    :_9ec4                                  SECTION ::mobs   
PARAMS  IX`mob          ``Address of the current mob being processed
{
        ld      a,[ix+#mob.unknown11]
        and     a
        ret     z
        dec     a
        ld      [ix+#mob.unknown11],a
        cp      $2f
        ret     nz
        ld      a,$19
        rst     :rst_playSFX
        ret
}

PROC    :_9ed4                                  SECTION ::mobs                  ;$9ED4
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        ld      [ix+#mob.width],$04
        ld      a,[ix+#mob.unknown11]
        srl     a
        srl     a
        srl     a
        srl     a
        and     $03
        ld      e,a
        ld      a,$03
        sub     e
        add     a,a
        add     a,a
        add     a,a
        add     a,a
        ld      [ix+#mob.height],a
        bit     0,[ix+#mob.flags]
        ret     nz
        ld      bc,$0000
        ld      de,$fff0
        call    :getFloorLayoutRAMAddressForMob
        ld      de,$0014
        ld      a,[hl]
        cp      $a3
        jr      z,._1
        ld      de,$0004
        set     1,[ix+#mob.flags]
._1     ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        add     hl,de
        ld      [ix+#mob.X+0],l
        ld      [ix+#mob.X+1],h
        ld      a,[ix+#mob.Y+0]
        ld      [ix+$12],a
        ld      a,[ix+#mob.Y+1]
        ld      [ix+#mob.unknown13],a
        set     0,[ix+#mob.flags]
        ret
}

;sprite layout
TABLE   :_9f2b                                  SECTION ::mobs                  ;$9F2B
{
        BYTE $0A, $FF, $FF, $FF, $FF, $FF
        BYTE $3E, $FF, $FF, $FF, $FF, $FF
        BYTE $0A, $FF, $FF, $FF, $FF, $FF

        BYTE $3E, $FF, $FF, $FF, $FF, $FF
        BYTE $0A, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $0A, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $FF
}

PROC    :mob_door_right                         SECTION ::mobs                  ;$9F62
        ;===============================================================================
        ;door - one way right (Scrap Brain)
        
PARAMS  IX`mob          ``Address of the current mob being processed
{
        set     5,[ix+#mob.flags]               ;mob does not collide with the floor
        call    :_9ed4
        ld      a,[ix+#mob.unknown11]
        cp      $28
        jr      nc,._2
        ld      hl,$0005
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        jr      c,._2
        ld      de,$0005
        ld      a,[$.SONIC.Xdirection]
        and     a
        jp      m,._1
        ld      de,$ffec
._1     ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        add     hl,de
        ld      [$.SONIC.X],hl
        
        xor     a`zero
        ld      [$.SONIC.Xspeed+0],a`zero
        ld      [$.SONIC.Xspeed+1],a`zero
        ld      [$.SONIC.Xdirection],a`zero
        
._2     ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      de,$fff0
        add     hl,de
        ld      de,[$.SONIC.X]
        xor     a`zero
        sbc     hl,de
        jr      nc,._3
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      bc,$0024
        add     hl,bc
        and     a
        sbc     hl,de
        jr      c,._3
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      de,$ffe0
        add     hl,de
        ld      de,[$.SONIC.Y]
        xor     a`zero
        sbc     hl,de
        jr      nc,._3
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      bc,$0050
        add     hl,bc
        and     a
        sbc     hl,de
        jr      c,._3
        call    :_9eb4
        jr      ._4
._3     call    :_9ec4
._4     ld      DE`spriteLayout ._9fee
        jp      :mob_door_left._9e7e
        
._9fee  ;sprite layout                                                          ;$9FEE
        BYTE $36, $FF, $FF, $FF, $FF, $FF
        BYTE $3E, $FF, $FF, $FF, $FF, $FF
        BYTE $36, $FF, $FF, $FF, $FF, $FF

        BYTE $3E, $FF, $FF, $FF, $FF, $FF
        BYTE $36, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $36, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $FF
}

PROC    :mob_door                               SECTION ::mobs                  ;$A025
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        set     5,[ix+#mob.flags]               ;mob does not collide with the floor
        call    :_9ed4
        ld      a,[ix+#mob.unknown11]
        cp      $28
        jr      nc,._2
        ld      hl,$0005
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        jr      c,._2
        ld      de,$0005
        ld      a,[$.SONIC.Xdirection]
        and     a
        jp      m,._1
        ld      de,$ffec
._1     ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        add     hl,de
        ld      [$.SONIC.X],hl
        
        xor     a`zero
        ld      [$.SONIC.Xspeed+0],a`zero
        ld      [$.SONIC.Xspeed+1],a`zero
        ld      [$.SONIC.Xdirection],a`zero
        
._2     ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      de,$ffc8
        add     hl,de
        ld      de,[$.SONIC.X]
        xor     a`zero
        sbc     hl,de
        jr      nc,._3
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      bc,$0024
        add     hl,bc
        and     a
        sbc     hl,de
        jr      c,._3
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      de,$ffe0
        add     hl,de
        ld      de,[$.SONIC.Y]
        xor     a`zero
        sbc     hl,de
        jr      nc,._3
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      bc,$0050
        add     hl,bc
        and     a
        sbc     hl,de
        jr      c,._3
        call    :_9eb4
        jr      ._4
        
._3     call    :_9ec4
._4     ld      de,:_a0b1
        jp      :mob_door_left._9e7e
}

;sprite layout
TABLE   :_a0b1                                  SECTION ::mobs                  ;$A0B1
{
        BYTE $38, $FF, $FF, $FF, $FF, $FF
        BYTE $3E, $FF, $FF, $FF, $FF, $FF
        BYTE $38, $FF, $FF, $FF, $FF, $FF

        BYTE $3E, $FF, $FF, $FF, $FF, $FF
        BYTE $38, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $38, $FF, $FF, $FF, $FF, $FF

        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $FF
}

INCLUDE "mobs\trap_electric.oz80"

PROC    :mob_badnick_ballHog                    SECTION ::mobs                  ;$A1AA
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        ld      [ix+#mob.width],$0a
        ld      [ix+#mob.height],$20
        ld      hl,$0803
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        ld      hl,$0e00
        ld      [$.TEMP1],hl
        call    nc,:hitPlayer
        ld      [ix+#mob.Yspeed+0],$00
        ld      [ix+#mob.Yspeed+1],$01
        ld      [ix+#mob.Ydirection],$00
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      de,$000a
        add     hl,de
        ex      de,hl
        ld      hl,[$.SONIC.X]
        ld      bc,$000c
        add     hl,bc
        and     a
        sbc     hl,de
        jr      nc,._3
        ld      bc,:_a2d2
        ld      a,[ix+#mob.unknown11]
        cp      $eb
        jr      c,._2
        jr      nz,._1
        ld      [ix+#mob.unknown16],$00
._1     ld      bc,:_a2d7
._2     ld      de,:_a2da
        call    :_7c41
        ld      a,[ix+#mob.unknown11]
        cp      $ed
        jp      nz,._6
        call    :findEmptyMob
        jp      c,._6
        ld      e,[ix+#mob.X+0]
        ld      d,[ix+#mob.X+1]
        ld      c,[ix+#mob.Y+0]
        ld      b,[ix+#mob.Y+1]
        push    ix
        push    hl
        pop     ix
        xor     a`zero                          ;set A to 0
        ld      [ix+#mob.type],$1C              ;ball from the Ball Hog
        ld      [ix+#mob.Xsubpixel],a`zero
        ld      [ix+#mob.X+0],e
        ld      [ix+#mob.X+1],d
        ld      hl,$0006
        add     hl,bc
        ld      [ix+#mob.Ysubpixel],a`zero
        ld      [ix+#mob.Y+0],l
        ld      [ix+#mob.Y+1],h
        ld      [ix+#mob.unknown11],a`zero
        ld      [ix+#mob.unknown16],a`zero
        ld      [ix+#mob.unknown17],a`zero
        ld      [ix+#mob.Xspeed+0],a`zero
        ld      [ix+#mob.Xspeed+1],$ff
        ld      [ix+#mob.Xdirection],$ff
        ld      [ix+#mob.Yspeed+0],a`zero
        ld      [ix+#mob.Yspeed+1],$01
        ld      [ix+#mob.Ydirection],a`zero
        pop     ix
        jp      ._6
        
._3     ld      bc,:_a2d2
        ld      a,[ix+#mob.unknown11]
        cp      $eb
        jr      c,._5
        jr      nz,._4
        ld      [ix+#mob.unknown16],$00
._4     ld      bc,:_a2d7
._5     ld      de,:_a30b
        call    :_7c41
        ld      a,[ix+#mob.unknown11]
        cp      $ed
        jr      nz,._6
        call    :findEmptyMob
        jp      c,._6
        ld      e,[ix+#mob.X+0]
        ld      d,[ix+#mob.X+1]
        ld      c,[ix+#mob.Y+0]
        ld      b,[ix+#mob.Y+1]
        push    ix
        push    hl
        pop     ix
        xor     a`zero                          ;set A to 0
        ld      [ix+#mob.type],$1C              ;ball from the Ball Hog
        ld      [ix+#mob.Xsubpixel],a`zero
        ld      [ix+#mob.X+0],e
        ld      [ix+#mob.X+1],d
        ld      hl,$0006
        add     hl,bc
        ld      [ix+#mob.Ysubpixel],a`zero
        ld      [ix+#mob.Y+0],l
        ld      [ix+#mob.Y+1],h
        ld      [ix+#mob.unknown11],a`zero
        ld      [ix+#mob.unknown16],a`zero
        ld      [ix+#mob.unknown17],a`zero
        ld      [ix+#mob.Xspeed+0],a`zero
        ld      [ix+#mob.Xspeed+1],$01
        ld      [ix+#mob.Xdirection],a`zero
        ld      [ix+#mob.Yspeed+0],a`zero
        ld      [ix+#mob.Yspeed+1],$01
        ld      [ix+#mob.Ydirection],a`zero
        pop     ix
._6     inc     [ix+#mob.unknown11]
        ret
}

TABLE   :_a2d2                                  SECTION ::mobs                  ;$A2D2
{
        BYTE $00, $1C, $01, $06, $FF
}
TABLE   :_a2d7                                  SECTION ::mobs                  ;$A2D7
{
        BYTE $02, $18, $FF
}

;sprite layout
TABLE   :_a2da                                  SECTION ::mobs                  ;$A2DA
{
        BYTE $40, $42, $FF, $FF, $FF, $FF
        BYTE $60, $62, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $44, $46, $FF, $FF, $FF, $FF
        BYTE $64, $66, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $40, $42, $FF, $FF, $FF, $FF
        BYTE $68, $6A, $FF, $FF, $FF, $FF
        BYTE $FF
}

TABLE   :_a30b                                  SECTION ::mobs                  ;$A30B
{
        BYTE $50, $52, $FF, $FF, $FF, $FF
        BYTE $70, $72, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $4C, $4E, $FF, $FF, $FF, $FF
        BYTE $6C, $6E, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $50, $52, $FF, $FF, $FF, $FF
        BYTE $48, $4A, $FF, $FF, $FF, $FF
        BYTE $FF
}

PROC    :_a33c                                  SECTION ::mobs                  ;$A33C
        ;===============================================================================
        ;mob: UNKNOWN (ball from Ball Hog?)
        
PARAMS  IX`mob          ``Address of the current mob being processed
{
        res     5,[ix+#mob.flags]               ;mob adheres to the floor
        ld      [ix+#mob.width],$0a
        ld      [ix+#mob.height],$0f
        ld      hl,$0101
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        call    nc,:hitPlayer._35fd
        bit     7,[ix+#mob.flags]
        jr      z,._1
        ld      [ix+#mob.Yspeed+0],$00
        ld      [ix+#mob.Yspeed+1],$fd
        ld      [ix+#mob.Ydirection],$ff
._1     ld      l,[ix+#mob.Yspeed+0]
        ld      h,[ix+#mob.Yspeed+1]
        ld      a,[ix+#mob.Ydirection]
        ld      de,$001f
        add     hl,de
        adc     a,$00
        ld      [ix+#mob.Yspeed+0],l
        ld      [ix+#mob.Yspeed+1],h
        ld      [ix+#mob.Ydirection],a
        ld      a,[ix+#mob.unknown11]
        cp      $82
        jr      nc,._2
        ld      bc,:_a3b1
        ld      de,:_a3bb
        call    :_7c41
        jp      ._4
        
._2     jr      nz,._3
        ld      [ix+#mob.unknown16],$00
        ld      a,$01
        rst     :rst_playSFX
._3     ld      bc,:_a3b4
        ld      de,:_a3bb
        call    :_7c41
._4     inc     [ix+#mob.unknown11]
        ld      a,[ix+#mob.unknown11]
        cp      $a5
        ret     c
        ld      [ix+#mob.type],$FF      ;remove mob?
        ret
}

TABLE   :_a3b1                                  SECTION ::mobs                  ;$A3B1
{
        BYTE $00, $08, $FF
}
TABLE   :_a3b4                                  SECTION ::mobs                  ;$A3B4
{
        BYTE $01, $0C, $02, $0C, $03, $0C, $FF
}

;sprite layout
TABLE   :_a3bb                                  SECTION ::mobs                  ;$A3BB
{
        BYTE $20, $22, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $74, $76, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $78, $7A, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF
        BYTE $FF, $FF, $FF, $FF, $FF, $FF

        BYTE $7C, $7E, $FF, $FF, $FF, $FF
        BYTE $FF
}

PROC    :mob_switch                             SECTION ::mobs                  ;$A3F8
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        ld      [ix+#mob.width],$0a
        ld      [ix+#mob.height],$11
        bit     0,[ix+#mob.flags]
        jr      nz,._1
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      de,$0008
        add     hl,de
        ld      [ix+#mob.X+0],l
        ld      [ix+#mob.X+1],h
        set     0,[ix+#mob.flags]
._1     ld      hl,$0001
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        jr      c,._3
        
        ld      a,[$.SONIC.Ydirection]
        and     a
        jp      m,._3
        
        ld      [ix+#mob.spriteLayout+0],LO :_a48b
        ld      [ix+#mob.spriteLayout+1],HI :_a48b
        ld      a,[$.LEVEL_SOLIDITY]
        cp      $03
        jr      nz,._2
        ld      [ix+#mob.spriteLayout+0],LO :_a49b
        ld      [ix+#mob.spriteLayout+1],HI :_a49b
._2     ld      bc,$0006
        ld      de,$0000
        call    :_LABEL_7CC1_12
        bit     1,[ix+#mob.flags]
        jr      nz,._4
        set     1,[ix+#mob.flags]
        ld      hl,$.D317
        call    ::main:getLevelBitFlag
        ld      a,[hl]
        xor     c
        ld      [hl],a
        ld      a,$1a
        rst     :rst_playSFX
        jr      ._4
        
._3     res     1,[ix+#mob.flags]
        ld      [ix+#mob.spriteLayout+0],LO :_a493
        ld      [ix+#mob.spriteLayout+1],HI :_a493
        ld      a,[$.LEVEL_SOLIDITY]
        cp      $03
        jr      nz,._4
        ld      [ix+#mob.spriteLayout+0],$a3
        ld      [ix+#mob.spriteLayout+1],$a4
._4     xor     a`zero
        ld      [ix+#mob.Yspeed+0],a`zero
        ld      [ix+#mob.Yspeed+1],$02
        ld      [ix+#mob.Ydirection],a`zero
        ret
}

;sprite layout
TABLE   :_a48b                                  SECTION ::mobs                  ;$A48B
{
        BYTE    $1A, $1C, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF
}
TABLE   :_a493                                  SECTION ::mobs                  ;$A493
{
        BYTE    $3A, $3C, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF
}
TABLE   :_a49b                                  SECTION ::mobs                  ;$A49B
{
        BYTE    $38, $3A, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $34, $36, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF
}

PROC    :mob_door_switchActivated               SECTION ::mobs                  ;$A4AB
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        set     5,[ix+#mob.flags]               ;mob does not collide with the floor
        call    :_9ed4
        ld      a,[ix+#mob.unknown11]
        cp      $28
        jr      nc,._2
        ld      hl,$0005
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        jr      c,._2
        ld      de,$0005
        ld      a,[$.SONIC.Xdirection]
        and     a
        jp      m,._1
        ld      de,$ffec
._1     ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        add     hl,de
        ld      [$.SONIC.X],hl
        
        xor     a`zero
        ld      [$.SONIC.Xspeed+0],a`zero
        ld      [$.SONIC.Xspeed+1],a`zero
        ld      [$.SONIC.Xdirection],a`zero
        
._2     ld      hl,$.D317
        call    ::main:getLevelBitFlag
        bit     1,[ix+#mob.flags]
        jr      z,._3
        ld      a,[hl]
        and     c
        jr      nz,._5
        jr      ._4
        
._3     ld      a,[hl]
        and     c
        jr      z,._5
._4     ld      a,[ix+#mob.unknown11]
        cp      $30
        jr      nc,._6
        inc     a
        inc     a
        ld      [ix+#mob.unknown11],a
        jr      ._6
        
._5     ld      a,[ix+#mob.unknown11]
        and     a
        jr      z,._6
        dec     a
        dec     a
        ld      [ix+#mob.unknown11],a
._6     ld      de,:_a51a
        jp      :mob_door_left._9e7e
}

;sprite layout
TABLE   :_a51a                                  SECTION ::mobs                  ;$A51A
{
        BYTE    $3E, $FF, $FF, $FF, $FF, $FF
        BYTE    $38, $FF, $FF, $FF, $FF, $FF
        BYTE    $3E, $FF, $FF, $FF, $FF, $FF
        
        BYTE    $38, $FF, $FF, $FF, $FF, $FF
        BYTE    $3E, $FF, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        
        BYTE    $3E, $FF, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        BYTE    $FF
}

PROC    :mob_badnick_caterkiller                SECTION ::mobs                  ;$A551
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        ld      [ix+#mob.width],$06
        ld      [ix+#mob.height],$10
        ld      a,[$.FRAMECOUNT]
        and     $01
        jr      nz,._5
        ld      hl,:_a6b9
        bit     1,[ix+#mob.flags]
        jr      z,._1
        ld      hl,:_a769
._1     ld      e,[ix+#mob.unknown11]
        sla     e
        ld      d,$00
        add     hl,de
        ld      c,[hl]
        inc     hl
        ld      b,[hl]
        ld      l,[ix+#mob.Xsubpixel]
        ld      h,[ix+#mob.X+0]
        ld      a,[ix+#mob.X+1]
        add     hl,bc
        bit     7,b
        jr      z,._2
        adc     a,$ff
        jr      ._3
        
._2     adc     a,$00
._3     ld      [ix+#mob.Xsubpixel],l
        ld      [ix+#mob.X+0],h
        ld      [ix+#mob.X+1],a
        ld      hl,:_a6e5
        add     hl,de
        ld      e,[hl]
        inc     hl
        ld      d,[hl]
        ld      l,[ix+$12]
        ld      h,[ix+#mob.unknown13]
        add     hl,de
        ld      [ix+$12],l
        ld      [ix+#mob.unknown13],h
        ld      c,$00
        bit     7,h
        jr      z,._4
        ld      c,$ff
._4     ld      [ix+#mob.unknown14],c
._5     ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      [$.TEMP1],hl
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      [$.TEMP3],hl
        bit     1,[ix+#mob.flags]
        jr      nz,._7
        ld      hl,:_a711
        ld      e,[ix+#mob.unknown11]
        ld      d,$00
        add     hl,de
        ld      a,$24
        call    :_a688
        ld      a,$26
        call    :_a6a2
        ld      a,$26
        call    :_a688
        ld      a,$26
        call    :_a6a2
        ld      [ix+#mob.width],$06
        ld      hl,$0802
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        ld      hl,$0000
        ld      [$.TEMP1],hl
        jr      c,._6
        call    :hitPlayer
        jr      ._9
        
._6     ld      [ix+#mob.width],$16
        ld      hl,$0806
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        call    nc,:hitPlayer._35fd
        jr      ._9
        
._7     ld      hl,:_a795
        ld      e,[ix+#mob.unknown11]
        ld      d,$00
        add     hl,de
        ld      a,$2a
        call    :_a688
        ld      a,$28
        call    :_a6a2
        ld      a,$28
        call    :_a688
        ld      a,$28
        call    :_a6a2
        ld      [ix+#mob.width],$10
        ld      hl,$0401
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        jr      c,._8
        call    :hitPlayer._35fd
        jr      ._9
        
._8     ld      [ix+#mob.width],$16
        ld      hl,$0410
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        ld      hl,$0000
        ld      [$.TEMP1],hl
        call    nc,:hitPlayer
._9     ld      [ix+#mob.Yspeed+1],$01
        ld      a,[$.FRAMECOUNT]
        and     $01
        ret     nz
        inc     [ix+#mob.unknown11]
        ld      a,[ix+#mob.unknown11]
        cp      $16
        ret     c
        ld      [ix+#mob.unknown11],$00
        inc     [ix+#mob.unknown15]
        ld      a,[ix+#mob.unknown15]
        cp      $14
        ret     c
        ld      [ix+#mob.unknown15],$00
        ld      a,[ix+#mob.flags]
        xor     $02
        ld      [ix+#mob.flags],a
        ret
}

PROC    :_a688                                  SECTION ::mobs                  ;$A688
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        push    hl
        ld      e,[hl]
        ld      d,$00
        ld      [$.TEMP4],de
        ld      l,[ix+#mob.unknown13]
        ld      h,[ix+#mob.unknown14]
        ld      [$.TEMP6],hl
        call    :_3581
        pop     hl
        ld      de,$0016
        add     hl,de
        ret
}

PROC    :_a6a2                                  SECTION ::mobs                  ;$A6A2
{
        push    hl
        ld      e,[hl]
        ld      d,$00
        ld      [$.TEMP4],de
        ld      hl,$0000
        ld      [$.TEMP6],hl
        call    :_3581
        pop     hl
        ld      de,$0016
        add     hl,de
        ret
}

TABLE   :_a6b9                                  SECTION ::mobs                  ;$A6B9
{
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $E0 $FF $E0 $FF $E0 $FF $E0 $FF $C0 $FF
        BYTE    $C0 $FF $80 $FF $80 $FF $00 $FF $00 $FF $00 $FE
}
TABLE   :_a6e5                                  SECTION ::mobs                  ;$A6E5
{
        BYTE    $00 $FF $80 $FF $80 $FF $C0 $FF $C0 $FF $E0 $FF $E0 $FF $F0 $FF
        BYTE    $F0 $FF $F0 $FF $F0 $FF $10 $00 $10 $00 $10 $00 $10 $00 $20 $00
        BYTE    $20 $00 $40 $00 $40 $00 $80 $00 $80 $00 $00 $01
}
TABLE   :_a711                                  SECTION ::mobs                  ;$A711
{
        BYTE    $00 $01 $02 $02 $03 $03 $03 $03 $03 $03 $03 $03 $03 $03 $03 $03
        BYTE    $03 $03 $02 $02 $01 $00 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07
        BYTE    $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $07 $0E $0D $0C $0C
        BYTE    $0B $0B $0B $0B $0B $0B $0B $0B $0B $0B $0B $0B $0B $0B $0C $0C
        BYTE    $0D $0E $15 $13 $12 $11 $10 $10 $0F $0F $0F $0F $0F $0F $0F $0F
        BYTE    $0F $0F $10 $10 $11 $12 $13 $15
}
TABLE   :_a769                                  SECTION ::mobs                  ;$A769
{
        BYTE    $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00 $00
        BYTE    $00 $00 $00 $00 $00 $00 $20 $00 $20 $00 $20 $00 $20 $00 $40 $00
        BYTE    $40 $00 $80 $00 $80 $00 $00 $01 $00 $01 $00 $02
}
TABLE   :_a795                                  SECTION ::mobs                  ;$A795
{
        BYTE    $15 $14 $13 $13 $12 $12 $12 $12 $12 $12 $12 $12 $12 $12 $12 $12
        BYTE    $12 $12 $13 $13 $14 $15 $0E $0E $0E $0E $0E $0E $0E $0E $0E $0E
        BYTE    $0E $0E $0E $0E $0E $0E $0E $0E $0E $0E $0E $0E $07 $08 $09 $09
        BYTE    $0A $0A $0A $0A $0A $0A $0A $0A $0A $0A $0A $0A $0A $0A $09 $09
        BYTE    $08 $07 $00 $02 $03 $04 $05 $05 $06 $06 $06 $06 $06 $06 $06 $06
        BYTE    $06 $06 $05 $05 $04 $03 $02 $00
}

PROC    :mob_boss_scrapBrain                    SECTION ::mobs                  ;$A7ED
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        ld      [ix+#mob.width],$1e
        ld      [ix+#mob.height],$2f
        bit     0,[ix+#mob.flags]
        jr      nz,._1
        ld      hl,$0340
        ld      [$.LEVEL_LEFT],hl
        
        ;lock the screen at 1344 pixels, 42 blocks
         ;(near the boss lift in Scrap Brain Act 3)
        ld      hl,$0540
        ld      [$.LEVEL_RIGHT],hl
        
        ld      hl,[$.CAMERA_Y]
        ld      [$.LEVEL_TOP],hl
        ld      [$.LEVEL_BOTTOM],hl
        ld      hl,$0220
        ld      [$.CAMERA_Y_GOTO],hl

        ;UNKNOWN
        ld      hl,$ef3f
        ld      de,$2000
        ld      a,12
        call    ::main:decompressArt

        ld      hl,:S1_BossPalette
        ld      a,%00000010
        call    ::interrupts:loadPaletteOnInterrupt
        
        ld      a,::sound:S1_MusicPointers.boss1.index     ;=$0B
        rst     :rst_playMusic
        
        set     0,[ix+#mob.flags]
._1     bit     1,[ix+#mob.flags]
        jr      nz,._4
        ld      hl,[$.CAMERA_X]
        ld      [$.LEVEL_LEFT],hl
        ld      de,:_baf9
        ld      bc,:_a9b7
        call    :_7c41
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      de,[$.SONIC.X]
        xor     a`zero
        sbc     hl,de
        ld      de,$0040
        xor     a`zero
        ld      bc,[$.SONIC.Xspeed]
        bit     7,b
        jr      nz,._2
        sbc     hl,de
        jr      c,._3
._2     ld      bc,$ff80
._3     inc     b
        ld      [ix+#mob.Xspeed+0],c
        ld      [ix+#mob.Xspeed+1],b
        ld      [ix+#mob.Xdirection],a
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      de,$05a0
        xor     a`zero
        sbc     hl,de
        jp      c,._9
        ld      l,a
        ld      h,a
        ld      [ix+#mob.Xspeed+0],a
        ld      [ix+#mob.Xspeed+1],a
        ld      [$.SONIC.Xspeed],hl
        ld      [$.SONIC.Xdirection],a
        set     1,[ix+#mob.flags]
        jp      ._9
        
._4     bit     2,[ix+#mob.flags]
        jr      nz,._5
        
        ld      hl,$0530
        ld      de,$0220
        call    :_7c8c
        
        ld      [iy+#vars.joypad],$ff
        ld      hl,$05a0
        ld      [ix+#mob.Xsubpixel],$00
        ld      [ix+#mob.X+0],l
        ld      [ix+#mob.X+1],h
        ld      [ix+#mob.spriteLayout+0],LO :_baf9
        ld      [ix+#mob.spriteLayout+1],HI :_baf9
        inc     [ix+#mob.unknown11]
        ld      a,[ix+#mob.unknown11]
        cp      $c0
        jp      c,._9
        set     2,[ix+#mob.flags]
        jp      ._9
        
._5     bit     3,[ix+#mob.flags]
        jr      nz,._6
        ld      [iy+#vars.joypad],$ff
        xor     a`zero
        ld      [ix+#mob.spriteLayout+0],a`zero
        ld      [ix+#mob.spriteLayout+1],a`zero
        dec     [ix+#mob.unknown11]
        jp      nz,._9
        set     3,[ix+#mob.flags]
        jp      ._9
        
._6     bit     4,[ix+#mob.flags]               ;mob underwater?
        jr      nz,._8
        ld      de,[$.SONIC.X]
        ld      hl,$0596
        and     a
        sbc     hl,de
        jr      nc,._9
        ld      hl,$05c0
        xor     a`zero
        sbc     hl,de
        jr      c,._9
        or      [ix+#mob.unknown11]
        jr      nz,._7
        ld      hl,[$.SONIC.Y]
        ld      de,$028d
        xor     a`zero
        sbc     hl,de
        jr      c,._9
        ld      l`zero,a`zero
        ld      h`zero,a`zero
        ld      [$.SONIC.Xspeed],hl`zero
        ld      [$.SONIC.Xdirection],a`zero
._7     ld      a,$80
        ld      [$.SONIC.flags],a
        ld      hl,$05a0
        ld      [$.SONIC.X],hl
        ld      [iy+#vars.joypad],$ff
        ld      e,[ix+#mob.unknown11]
        ld      d,$00
        ld      hl,$028e
        xor     a`zero                          ;set A to 0
        sbc     hl,de
        ld      [$.SONIC.Ysubpixel],a`zero
        ld      [$.SONIC.Y],hl
        ld      a,[$.D2E8]
        ld      hl,[$.D2E6]
        ld      [$.SONIC.Yspeed],hl
        ld      [$.SONIC.Ydirection],a
        inc     [ix+#mob.unknown11]
        ld      a,[ix+#mob.unknown11]
        cp      $c0
        jr      nz,._9
        ld      hl,[$.CAMERA_X]
        inc     h
        ld      [$.SONIC.X],hl
        set     4,[ix+#mob.flags]               ;set mob underwater
        
        ld      a,::sound:S1_MusicPointers.actComplete.index ;=$09
        rst     :rst_playMusic
        
        ld      a,$a0
        ld      [$.D289],a
        set     1,[iy+#vars.flags6]
        ret
        
._8     ld      a,[ix+#mob.unknown11]
        and     a
        jr      z,._9
        dec     [ix+#mob.unknown11]
._9     ld      e,[ix+#mob.unknown11]
        ld      d,$00
        ld      hl,$0280
        xor     a`zero
        sbc     hl,de
        ld      [ix+#mob.Ysubpixel],a`zero
        ld      [ix+#mob.Y+0],l
        ld      [ix+#mob.Y+1],h
        ld      e,[ix+#mob.unknown11]
        ld      d,$00
        ld      hl,$02af
        and     a
        sbc     hl,de
        ld      bc,[$.CAMERA_Y]
        and     a
        sbc     hl,bc
        ex      de,hl
        ld      hl,$05a0
        ld      bc,[$.CAMERA_X]
        and     a
        sbc     hl,bc
        ld      bc,:_a9c0               ;address of sprite layout
        call    :processSpriteLayout
        ld      a,[ix+#mob.unknown11]
        and     $1f
        cp      $0f
        ret     nz
        ld      a,$19
        rst     :rst_playSFX
        ret
}

TABLE   :_a9b7                                  SECTION ::mobs                  ;$A9B7
{
        BYTE    $03, $08, $04, $07, $05, $08, $04, $07, $FF
}

;sprite layout
TABLE   :_a9c0                                  SECTION ::mobs                  ;$A9C0
{
        BYTE    $74, $76, $76, $78, $FF, $FF
        BYTE    $FF
}

PROC    :mob_meta_clouds                        SECTION ::mobs                  ;$A9C7
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        set     5,[ix+#mob.flags]               ;mob does not collide with the floor
        ld      a,[iy+#vars.spriteUpdateCount]
        ld      hl,[$.SPRITETABLE_ADDR]
        push    af
        push    hl
        ld      a,[$.D2DE]
        cp      $24
        jr      nc,._1
        ld      e,a
        ld      d,$00
        ld      hl,$.SPRITETABLE
        add     hl,de
        ld      [$.SPRITETABLE_ADDR],hl
        ld      a,[$.D2A3]
        ld      c,a
        ld      de,[$.D2A1]
        ld      l,[ix+#mob.Ysubpixel]
        ld      h,[ix+#mob.Y+0]
        ld      a,[ix+#mob.Y+1]
        add     hl,de
        adc     a,c
        ld      l,h
        ld      h,a
        ld      bc,[$.CAMERA_Y]
        and     a
        sbc     hl,bc
        ex      de,hl
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      bc,[$.CAMERA_X]
        and     a
        sbc     hl,bc
        ld      bc,:_aa63               ;address of sprite layout
        call    :processSpriteLayout
        ld      a,[$.D2DE]
        add     a,$0c
        ld      [$.D2DE],a
._1     pop     hl
        pop     af
        ld      [$.SPRITETABLE_ADDR],hl
        ld      [iy+#vars.spriteUpdateCount],a
        ld      hl,[$.CAMERA_X]
        ld      de,$ffe0
        add     hl,de
        ex      de,hl
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        and     a
        sbc     hl,de
        jr      nc,._2
        call    ::main:_LABEL_625_57
        ld      b,$00
        add     a,a
        ld      c,a
        rl      b
        ld      hl,[$.CAMERA_X]
        ld      de,$01b4
        add     hl,de
        add     hl,bc
        ld      [ix+#mob.X+0],l
        ld      [ix+#mob.X+1],h
._2     ld      [ix+#mob.Xspeed+0],$00
        ld      [ix+#mob.Xspeed+1],$fd
        ld      [ix+#mob.Xdirection],$ff
        ld      [ix+#mob.spriteLayout+0],$00
        ld      [ix+#mob.spriteLayout+1],$00
        ret
}

;sprite layout
TABLE   :_aa63                                  SECTION ::mobs                  ;$AA63
{
        BYTE $40, $42, $44, $46, $FF, $FF
        BYTE $FF
}

INCLUDE "mobs\trap_propeller.oz80"

PROC    :mob_badnick_bomb                       SECTION ::mobs                  ;$AB21
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        ld      [ix+#mob.width],$0c
        ld      [ix+#mob.height],$10
        ld      a,[ix+#mob.unknown11]
        cp      $64
        jr      nc,._1
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      de,$ffc8
        add     hl,de
        ex      de,hl
        ld      hl,[$.SONIC.X]
        and     a
        sbc     hl,de
        jr      c,._1
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      de,$002c
        add     hl,de
        ex      de,hl
        ld      hl,[$.SONIC.X]
        and     a
        sbc     hl,de
        jr      nc,._1
        ld      [ix+#mob.unknown11],$64
._1     ld      a,[ix+#mob.unknown11]
        cp      $1e
        jr      nc,._2
        ld      [ix+#mob.Xspeed+0],$f8
        ld      [ix+#mob.Xspeed+1],$ff
        ld      [ix+#mob.Xdirection],$ff
        ld      de,:_ad0b
        ld      bc,:_acf1
        call    :_7c41
        jp      ._7
        
._2     ld      a,[ix+#mob.unknown11]
        cp      $64
        jp      c,._4
        ld      [ix+#mob.Xspeed+0],$00
        ld      [ix+#mob.Xspeed+1],$00
        ld      [ix+#mob.Xdirection],$00
        cp      $66
        jr      nc,._3
        ld      de,:_ad0b
        ld      bc,:_ad01
        call    :_7c41
        jp      ._7
        
._3     ld      [ix+#mob.spriteLayout+0],LO :_ad53
        ld      [ix+#mob.spriteLayout+1],HI :_ad53
        cp      $67
        jp      nz,._7
        ld      hl,$fffe
        ld      [$.TEMP4],hl
        ld      hl,$fffc
        ld      [$.TEMP6],hl
        call    :findEmptyMob
        jp      c,._8
        ld      de,$0000
        ld      c,e
        ld      b,d
        call    :_ac96
        ld      hl,$0003
        ld      [$.TEMP4],hl
        ld      hl,$fffc
        ld      [$.TEMP6],hl
        call    :findEmptyMob
        jp      c,._8
        ld      de,$0008
        ld      bc,$0000
        call    :_ac96
        ld      hl,$fffe
        ld      [$.TEMP4],hl
        ld      hl,$fffe
        ld      [$.TEMP6],hl
        call    :findEmptyMob
        jp      c,._8
        ld      de,$0000
        ld      bc,$0008
        call    :_ac96
        ld      hl,$0003
        ld      [$.TEMP4],hl
        ld      hl,$fffe
        ld      [$.TEMP6],hl
        call    :findEmptyMob
        jp      c,._8
        ld      de,$0008
        ld      bc,$0008
        call    :_ac96
        ld      [ix+#mob.type],$FF              ;remove mob?
        ld      a,$1b
        rst     :rst_playSFX
        jr      ._8
        
._4     cp      $23
        jr      nc,._5
        xor     a`zero
        ld      [ix+#mob.Xspeed+0],a`zero
        ld      [ix+#mob.Xspeed+1],a`zero
        ld      [ix+#mob.Xdirection],a`zero
        ld      de,:_ad0b
        ld      bc,:_acf6
        call    :_7c41
        jr      ._7
        
._5     ld      a,[ix+#mob.unknown11]
        cp      $41
        jr      nc,._6
        ld      [ix+#mob.Xspeed+0],$08
        ld      [ix+#mob.Xspeed+1],$00
        ld      [ix+#mob.Xdirection],$00
        ld      de,:_ad0b
        ld      bc,:_acf9
        call    :_7c41
        jr      ._7
        
._6     ld      [ix+#mob.Xspeed+0],$00
        ld      [ix+#mob.Xspeed+1],$00
        ld      [ix+#mob.Xdirection],$00
        ld      de,:_ad0b
        ld      bc,:_acfe
        call    :_7c41
._7     ld      [ix+#mob.Yspeed+0],$80
        ld      [ix+#mob.Yspeed+1],$00
        ld      [ix+#mob.Ydirection],$00
._8     ld      hl,$0202
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        call    nc,:hitPlayer._35fd
        ld      a,[$.FRAMECOUNT]
        and     $3f
        ret     nz
        inc     [ix+#mob.unknown11]
        ld      a,[ix+#mob.unknown11]
        cp      $46
        ret     nz
        ld      [ix+#mob.unknown11],$00
        ret
}

PROC    :_ac96                                  SECTION ::mobs                  ;$AC96
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        push    ix
        push    hl
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        add     hl,de
        ex      de,hl
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        add     hl,bc
        ld      c,l
        ld      b,h
        pop     ix
        xor     a`zero                          ;set A to 0
        ld      [ix+#mob.type],$0D              ;unknown mob
        ld      [ix+#mob.Xsubpixel],a`zero
        ld      [ix+#mob.X+0],e
        ld      [ix+#mob.X+1],d
        ld      [ix+#mob.Ysubpixel],a`zero
        ld      [ix+#mob.Y+0],c
        ld      [ix+#mob.Y+1],b
        ld      [ix+#mob.unknown11],a`zero
        ld      [ix+#mob.unknown13],$24
        ld      [ix+#mob.unknown14],a`zero
        ld      [ix+#mob.unknown15],a`zero
        ld      [ix+#mob.unknown16],a`zero
        ld      [ix+#mob.unknown17],a`zero
        ld      [ix+#mob.Xspeed+0],a`zero
        ld      hl,[$.TEMP4]
        ld      [ix+#mob.Xspeed+1],l
        ld      [ix+#mob.Xdirection],h
        ld      [ix+#mob.Yspeed+0],a`zero
        ld      hl,[$.TEMP6]
        ld      [ix+#mob.Yspeed+1],l
        ld      [ix+#mob.Ydirection],h
        pop     ix
        ret
}

TABLE   :_acf1                                  SECTION ::mobs                  ;$ACF1
{
        BYTE    $00, $20, $01, $20, $FF
}
TABLE   :_acf6                                  SECTION ::mobs                  ;$ACF6
{       
        BYTE    $01, $20, $FF
}
TABLE   :_acf9                                  SECTION ::mobs                  ;$ACF9
{
        BYTE    $02, $20, $03, $20, $FF
}
TABLE   :_acfe                                  SECTION ::mobs                  ;$ACFE
{
        BYTE    $03, $20, $FF
}
TABLE   :_ad01                                  SECTION ::mobs                  ;$AD01
{
        BYTE    $01, $02, $04, $02, $FF
        BYTE    $03, $02, $05, $02, $FF
}

;sprite layout
TABLE   :_ad0b                                  SECTION ::mobs                  ;$AD0B
{
        BYTE    $0A, $0C, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        
        BYTE    $0E, $10, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        
        BYTE    $2A, $2C, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        
        BYTE    $2E, $30, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
}

TABLE   :_ad53                                  SECTION ::mobs                  ;$AD53
{
        BYTE    $12, $14, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
        BYTE    $32, $34, $FF, $FF, $FF, $FF
        BYTE    $FF
}

INCLUDE "mobs\trap_cannon.oz80"

PROC    :mob_badnick_unidos                     SECTION ::mobs                  ;$AE88
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        set     5,[ix+#mob.flags]               ;mob does not collide with the floor
        bit     0,[ix+#mob.flags]
        jr      nz,._1
        ld      [ix+#mob.unknown11],$00
        ld      [ix+$12],$2a
        ld      [ix+#mob.unknown13],$52
        ld      [ix+#mob.unknown14],$7c
        set     0,[ix+#mob.flags]
._1     ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      de,[$.SONIC.X]
        and     a
        sbc     hl,de
        jr      c,._2
        ld      [ix+#mob.Xspeed+0],$f8
        ld      [ix+#mob.Xspeed+1],$ff
        ld      [ix+#mob.Xdirection],$ff
        ld      [ix+#mob.spriteLayout+0],LO :_b0d5
        ld      [ix+#mob.spriteLayout+1],HI :_b0d5
        ld      hl,$ff80
        ld      [$.D216],hl
        call    :_af98
        ld      [ix+#mob.unknown16],$01
        jr      ._3
        
._2     ld      [ix+#mob.Xspeed+0],$08
        ld      [ix+#mob.Xspeed+1],$00
        ld      [ix+#mob.Xdirection],$00
        ld      [ix+#mob.spriteLayout+0],LO :_b0e7
        ld      [ix+#mob.spriteLayout+1],HI :_b0e7
        ld      hl,$0080
        ld      [$.D216],hl
        call    :_af98
        ld      [ix+#mob.unknown16],$ff
._3     ld      [ix+#mob.width],$1c
        ld      [ix+#mob.height],$1c
        ld      hl,$1212
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        ld      hl,$1010
        ld      [$.TEMP1],hl
        call    nc,:hitPlayer
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      [$.TEMP1],hl
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      [$.TEMP3],hl
        push    ix
        pop     hl
        ld      de,$0011
        add     hl,de
        
        ld      b,$04
.loop   push    bc
        push    hl
        ld      a,[hl]
        cp      $fe
        jr      z,._4
        and     $fe
        ld      e,a
        ld      d,$00
        ld      hl,:_b031
        add     hl,de
        push    hl
        ld      e,[hl]
        ld      [$.TEMP4],de
        inc     hl
        ld      e,[hl]
        ld      [$.TEMP6],de
        ld      a,$24
        call    :_3581
        pop     hl
        ld      a,[hl]
        inc     a
        inc     a
        ld      [$.TEMP6],a
        add     a,$04
        ld      [ix+#mob.width],a
        inc     hl
        ld      a,[hl]
        inc     a
        inc     a
        ld      [$.TEMP7],a
        add     a,$04
        ld      [ix+#mob.height],a
        call    :detectCollisionWithSonic
        call    nc,:hitPlayer._35fd
._4     pop     hl
        pop     bc
        ld      a,[hl]
        cp      $fe
        jr      z,._6
        add     a,[ix+#mob.unknown16]
        cp      $ff
        jr      nz,._5
        ld      a,$a3
        jr      ._6
        
._5     cp      $a4
        jr      nz,._6
        xor     a`zero
._6     ld      [hl],a`zero
        inc     hl
        djnz    .loop
        
        ld      a,[$.FRAMECOUNT]
        and     $07
        ret     z
        ld      a,[ix+#mob.unknown15]
        cp      $c8
        ret     nc
        inc     [ix+#mob.unknown15]
        ret
}

PROC    :_af98                                  SECTION ::mobs                  ;$AF98
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        ld      a,[ix+#mob.unknown15]
        cp      $c8
        ret     nz
        ld      a,[$.LEVEL_SOLIDITY]
        cp      $03
        ret     nz
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      de,$ffd0
        add     hl,de
        ld      de,[$.SONIC.Y]
        and     a
        sbc     hl,de
        ret     nc
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      bc,$002c
        add     hl,bc
        and     a
        sbc     hl,de
        ret     c
        push    ix
        pop     hl
        ld      de,$0011
        add     hl,de
        ld      b,$04
        
.loop   push    bc
        push    hl
        ld      a,[hl]
        cp      $4a
        call    z,:_afdb
        pop     hl
        pop     bc
        inc     hl
        djnz    .loop
        
        ret
}

PROC    :_afdb                                  SECTION ::mobs                  ;$AFDB
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        ld      [hl],$fe
        call    :findEmptyMob
        ret     c
        push    ix
        ld      e,[ix+#mob.X+0]
        ld      d,[ix+#mob.X+1]
        ld      c,[ix+#mob.Y+0]
        ld      b,[ix+#mob.Y+1]
        push    hl
        pop     ix
        xor     a`zero                          ;set A to 0
        ld      [ix+#mob.type],$36              ;unknown mob
        ld      [ix+#mob.Xsubpixel],a`zero
        ld      hl,$0012
        add     hl,de
        ld      [ix+#mob.X+0],l
        ld      [ix+#mob.X+1],h
        ld      [ix+#mob.Ysubpixel],a`zero
        ld      hl,$001e
        add     hl,bc
        ld      [ix+#mob.Y+0],l
        ld      [ix+#mob.Y+1],h
        ld      hl,[$.D216]
        ld      [ix+#mob.Xspeed+0],l
        ld      [ix+#mob.Xspeed+1],h
        xor     a`zero
        bit     7,h
        jr      z,._1
        ld      a,$ff
._1     ld      [ix+#mob.Xdirection],a
        xor     a`zero
        ld      [ix+#mob.Yspeed+0],a`zero
        ld      [ix+#mob.Yspeed+1],a`zero
        ld      [ix+#mob.Ydirection],a`zero
        pop     ix
        ret
}

TABLE   :_b031                                  SECTION ::mobs                  ;$B031
{
        BYTE    $0C $03 $0D $03 $0E $03 $0E $04 $0F $04 $10 $04 $10 $05 $11 $05
        BYTE    $11 $06 $12 $06 $12 $07 $13 $07 $13 $08 $13 $09 $14 $09 $14 $0A
        BYTE    $14 $0B $15 $0B $15 $0C $15 $0D $15 $0E $15 $0F $15 $10 $15 $11
        BYTE    $14 $11 $14 $12 $14 $13 $13 $13 $13 $14 $13 $15 $12 $15 $12 $16
        BYTE    $11 $16 $11 $17 $10 $17 $10 $18 $0F $18 $0E $18 $0E $19 $0D $19
        BYTE    $0C $19 $0B $19 $0A $19 $09 $19 $09 $18 $08 $18 $07 $18 $07 $17
        BYTE    $06 $17 $06 $16 $05 $16 $05 $15 $04 $15 $04 $14 $04 $13 $03 $13
        BYTE    $03 $12 $03 $11 $02 $11 $02 $10 $02 $0F $02
}
TABLE   :_b0ac                                  SECTION ::mobs                  ;$B0AC
{
        BYTE    $0E $02 $0D $02 $0C $02 $0B $03 $0B $03 $0A $03 $09 $04 $09 $04
        BYTE    $08 $04 $07 $05 $07 $05 $06 $06 $06 $06 $05 $07 $05 $07 $04 $08
        BYTE    $04 $09 $04 $09 $03 $0A $03 $0B $03
}

;sprite layout
TABLE   :_b0d5                                  SECTION ::mobs                  ;$B0D5
{
        BYTE    $FE, $FF, $FF, $FF, $FF, $FF
        BYTE    $FE, $26, $28, $FF, $FF, $FF
        BYTE    $FF, $FF, $FF, $FF, $FF, $FF
}
TABLE   :_b0e7                                  SECTION ::mobs                  ;$B0E7
{
        BYTE    $FE, $FF, $FF, $FF, $FF, $FF
        BYTE    $FE, $20, $22, $FF, $FF, $FF
        BYTE    $FF
}

PROC    :_b0f4                                  SECTION ::mobs                  ;$B0F4
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        set     5,[ix+#mob.flags]               ;mob does not collide with the floor
        ld      [ix+#mob.spriteLayout+0],$00
        ld      [ix+#mob.spriteLayout+1],$00
        ld      [ix+#mob.width],$04
        ld      [ix+#mob.height],$0a
        ld      hl,$0602
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        call    nc,:hitPlayer._35fd
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      [$.TEMP1],hl
        ex      de,hl
        ld      hl,[$.CAMERA_X]
        ld      bc,$fff0
        add     hl,bc
        and     a
        sbc     hl,de
        jr      nc,._1
        ld      hl,[$.CAMERA_X]
        ld      bc,$0110
        add     hl,bc
        and     a
        sbc     hl,de
        jr      c,._1
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      [$.TEMP3],hl
        ex      de,hl
        ld      hl,[$.CAMERA_Y]
        ld      bc,$fff0
        add     hl,bc
        and     a
        sbc     hl,de
        jr      nc,._1
        ld      hl,[$.CAMERA_Y]
        ld      bc,$00d0
        add     hl,bc
        and     a
        sbc     hl,de
        jr      c,._1
        ld      hl,$0000
        ld      [$.TEMP4],hl
        ld      [$.TEMP6],hl
        ld      a,$24
        call    :_3581
        ret
        
._1     ld      [ix+#mob.type],$FF      ;remove mob?
        ret
}

PROC    :mob_trap_turretRotating                SECTION ::mobs                  ;$B16C
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        set     5,[ix+#mob.flags]               ;mob does not collide with the floor
        bit     0,[ix+#mob.flags]
        jr      nz,._1
        call    ::main:_LABEL_625_57
        and     $07
        ld      [ix+#mob.unknown11],a
        set     0,[ix+#mob.flags]
._1     ld      [ix+#mob.spriteLayout+0],$00
        ld      [ix+#mob.spriteLayout+1],$00
        ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      [$.TEMP1],hl
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      [$.TEMP3],hl
        ld      a,[ix+#mob.unknown11]
        add     a,a
        add     a,a
        add     a,a
        ld      e,a
        ld      d,$00
        ld      hl,:_b227
        add     hl,de
        ld      b,$02
        
.loop   push    bc
        ld      d,$00
        ld      e,[hl]
        bit     7,e
        jr      z,._2
        ld      d,$ff
._2     ld      [$.TEMP4],de
        inc     hl
        ld      d,$00
        ld      e,[hl]
        bit     7,e
        jr      z,._3
        ld      d,$ff
._3     ld      [$.TEMP6],de
        inc     hl
        ld      a,[hl]
        inc     hl
        inc     hl
        cp      $ff
        jr      z,._4
        push    hl
        call    :_3581
        pop     hl
._4     pop     bc
        djnz    .loop
        
        ld      a,[$.FRAMECOUNT]
        and     $3f
        jr      nz,._5
        ld      a,[ix+#mob.unknown11]
        inc     a
        and     $07
        ld      [ix+#mob.unknown11],a
._5     inc     [ix+$12]
        ld      a,[ix+$12]
        cp      $1a
        ret     nz
        ld      [ix+$12],$00
        ld      a,[ix+#mob.unknown11]
        add     a,a
        ld      e,a
        add     a,a
        add     a,e
        ld      e,a
        ld      d,$00
        ld      hl,:_b267
        add     hl,de
        ld      e,[hl]
        inc     hl
        ld      d,[hl]
        inc     hl
        ld      [$.TEMP4],de
        ld      e,[hl]
        inc     hl
        ld      d,[hl]
        ld      [$.TEMP6],de
        inc     hl
        ld      e,[hl]
        ld      d,$00
        bit     7,e
        jr      z,._6
        dec     d
._6     inc     hl
        ld      c,[hl]
        ld      b,$00
        bit     7,c
        jr      z,._7
        dec     b
._7     call    :_b5c2
        ret
}

TABLE   :_b227                                  SECTION ::mobs                  ;$B227
{
        BYTE    $08 $F8 $66 $00 $00 $00 $FF $00 $0C $FA $70 $00 $14 $FA $72 $00
        BYTE    $0F $07 $4C $00 $17 $07 $4E $00 $0D $0C $6C $00 $15 $0C $6E $00
        BYTE    $08 $0F $64 $00 $00 $00 $FF $00 $FC $0C $68 $00 $04 $0C $6A $00
        BYTE    $F9 $07 $48 $00 $01 $07 $4A $00 $FB $F9 $50 $00 $03 $F9 $52 $00   
}
TABLE   :_b267                                  SECTION ::mobs                  ;$B267
{
        BYTE    $00 $00 $00 $FE $08 $F0 $00 $01 $00 $FF $18 $F8 $00 $02 $00 $00
        BYTE    $1E $07 $00 $01 $00 $01 $16 $16 $00 $00 $00 $02 $08 $20 $00 $FF
        BYTE    $00 $01 $F8 $18 $00 $FE $00 $00 $F2 $07 $00 $FF $00 $FF $F7 $F6
}

PROC    :mob_platform_flyingRight               SECTION ::mobs                  ;$B297
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        set     5, [ix+#mob.flags]
        bit     0, [ix+#mob.flags]
        jr      nz,._1
        
        ld      a,[ix+#mob.Ysubpixel]
        ld      [ix+$12],a
        
        ld      a,[ix+#mob.Y+0]
        ld      [ix+#mob.unknown13],a
        
        ld      a,[ix+#mob.Y+1]
        ld      [ix+#mob.unknown14],a
        
        set     0,[ix+#mob.flags]
        
._1     ld      a,[$.D2A3]
        ld      c,a
        ld      de,[$.D2A1]
        ld      l,[ix+$12]
        ld      h,[ix+#mob.unknown13]
        ld      a,[ix+#mob.unknown14]
        add     hl,de
        adc     a,c
        ld      [ix+#mob.Ysubpixel],l
        ld      [ix+#mob.Y+0],h
        ld      [ix+#mob.Y+1],a
        
        ld      a,[$.SONIC.Ydirection]
        and     a
        jp      m,._2
        
        ld      [ix+#mob.width],$1e
        ld      [ix+#mob.height],$10
        ld      hl,$0a02
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        jr      c,._2
        
        ld      hl,$0030
        ld      [$.D26B],hl
        ld      hl,$0030
        ld      [$.D26D],hl
        ld      bc,$0010
        ld      de,$0000
        call    :_LABEL_7CC1_12
        ld      l,[ix+#mob.Xsubpixel]
        ld      h,[ix+#mob.X+0]
        ld      a,[ix+#mob.X+1]
        ld      de,$0080
        add     hl,de
        adc     a,$00
        ld      [ix+#mob.Xsubpixel],l
        ld      [ix+#mob.X+0],h
        ld      [ix+#mob.X+1],a
        ld      hl,[$.SONIC.Xsubpixel]
        ld      a,[$.SONIC.X+1]
        add     hl,de
        adc     a,$00
        ld      [$.SONIC.Xsubpixel],hl
        ld      [$.SONIC.X+1],a
._2     ld      l,[ix+#mob.X+0]
        ld      h,[ix+#mob.X+1]
        ld      [$.TEMP1],hl
        ld      l,[ix+#mob.Y+0]
        ld      h,[ix+#mob.Y+1]
        ld      [$.TEMP3],hl
        ld      hl,$fff8
        ld      [$.TEMP4],hl
        ld      e,[ix+#mob.unknown11]
        ld      d,$00
        ld      hl,:_b388
        add     hl,de
        ld      b,$02
        
.loop   push    bc
        ld      e,[hl]
        ld      d,$00
        inc     hl
        ld      [$.TEMP6],de
        ld      a,[hl]
        inc     hl
        cp      $ff
        jr      z,._3
        push    hl
        call    :_3581
        pop     hl
._3     pop     bc
        djnz    .loop
        
        ld      [ix+#mob.spriteLayout+0],LO :_b37b
        ld      [ix+#mob.spriteLayout+1],HI :_b37b
        ld      a,[ix+#mob.unknown11]
        add     a,$04
        ld      [ix+#mob.unknown11],a
        cp      $10
        ret     c
        ld      [ix+#mob.unknown11],$00
        ret
}

;sprite layout
TABLE   :_b37b                                  SECTION ::mobs                  ;$B37B
{
        BYTE    $FE, $FF, $FF, $FF, $FF, $FF
        BYTE    $36, $36, $36, $36, $FF, $FF
        BYTE    $FF
}
TABLE   :_b388                                  SECTION ::mobs                  ;$B388
{
        BYTE    $08 $1C $18 $3C $08 $1E $18 $3E $08 $38 $18 $3A $0C $1A $00 $FF
}

INCLUDE "mobs\trap_spikewall.oz80"


PROC    :mob_trap_turretFixed                   SECTION ::mobs                  ;$B46D
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        set     5,[ix+#mob.flags]               ;mob does not collide with the floor
        bit     0,[ix+#mob.flags]
        jr      nz,._1
        ld      bc,$0000
        ld      e,c
        ld      d,b
        call    :getFloorLayoutRAMAddressForMob
        ld      a,[hl]
        sub     $3c
        cp      $04
        ret     nc
        ld      [ix+#mob.unknown11],a
        set     0,[ix+#mob.flags]
._1     inc     [ix+$12]
        ld      a,[ix+$12]
        bit     6,a
        ret     nz
        and     $0f
        ret     nz
        ld      a,[ix+#mob.unknown11]
        add     a,a
        ld      e,a
        add     a,a
        add     a,a
        add     a,e
        ld      e,a
        ld      d,$00
        ld      hl,._b4e6
        add     hl,de
        ld      e,[hl]
        inc     hl
        ld      d,[hl]
        inc     hl
        ld      [$.TEMP4],de
        ld      e,[hl]
        inc     hl
        ld      d,[hl]
        inc     hl
        ld      [$.TEMP6],de
        ld      e,[hl]
        inc     hl
        ld      d,[hl]
        inc     hl
        ld      c,[hl]
        inc     hl
        ld      b,[hl]
        inc     hl
        exx     
        ld      e,[ix+#mob.X+0]
        ld      d,[ix+#mob.X+1]
        ld      hl,[$.SONIC.X]
        and     a
        sbc     hl,de
        ld      a,h
        exx     
        cp      [hl]
        ret     nz
        inc     hl
        exx     
        ld      e,[ix+#mob.Y+0]
        ld      d,[ix+#mob.Y+1]
        ld      hl,[$.SONIC.Y]
        and     a
        sbc     hl,de
        ld      a,h
        exx     
        cp      [hl]
        ret     nz
        call    :_b5c2
        ret

._b4e6  BYTE    $80 $FE $80 $FE $00 $00 $F8 $FF $FF $FF $80 $01 $80 $FE $18 $00
        BYTE    $F8 $FF $00 $FF $80 $FE $80 $01 $00 $00 $10 $00 $FF $00 $80 $01
        BYTE    $80 $01 $18 $00 $10 $00 $00 $00   
}

PROC    :mob_platform_flyingUpDown              SECTION ::mobs                  ;$B50E
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        set     5,[ix+#mob.flags]               ;mob does not collide with the floor
        ld      hl,:_b37b
        ld      a,[$.LEVEL_SOLIDITY]
        cp      $01
        jr      nz,._1
        ld      hl,._b5b5
._1     ld      [ix+#mob.spriteLayout+0],l
        ld      [ix+#mob.spriteLayout+1],h
        ld      a,$50
        ld      [$.D216],a
        call    ._b53b
        inc     [ix+#mob.unknown11]
        ld      a,[ix+#mob.unknown11]
        cp      $a0
        ret     c
        ld      [ix+#mob.unknown11],$00
        ret

        ;--------------------------------------------------------------------[$B53B]----

._b53b  ld      a,[$.D216]
        ld      l,a
        ld      de,$0010
        ld      c,$00
        ld      a,[ix+#mob.unknown11]
        cp      l
        jr      c,._2
        dec     c
        ld      de,$fff0
._2     ld      l,[ix+#mob.Yspeed+0]
        ld      h,[ix+#mob.Yspeed+1]
        ld      a,[ix+#mob.Ydirection]
        add     hl,de
        adc     a,c
        ld      [ix+#mob.Yspeed+0],l
        ld      [ix+#mob.Yspeed+1],h
        ld      [ix+#mob.Ydirection],a
        ld      a,h
        and     a
        jp      p,._3
        ld      a,l
        cpl     
        ld      l,a
        ld      a,h
        cpl     
        ld      h,a
        inc     hl
        ld      a,h
        cp      $02
        jr      c,._4
        ld      [ix+#mob.Yspeed+0],$00
        ld      [ix+#mob.Yspeed+1],$fe
        ld      [ix+#mob.Ydirection],$ff
        jr      ._4
        
._3     cp      $02
        jr      c,._4
        ld      [ix+#mob.Yspeed+0],$00
        ld      [ix+#mob.Yspeed+1],$02
        ld      [ix+#mob.Ydirection],$00
        
._4     ld      a,[$.SONIC.Ydirection]
        and     a
        ret     m
        
        ld      [ix+#mob.width],$1e
        ld      [ix+#mob.height],$1c
        ld      hl,$0802
        ld      [$.TEMP6],hl
        call    :detectCollisionWithSonic
        ret     c
        ld      e,[ix+#mob.Yspeed+0]
        ld      d,[ix+#mob.Yspeed+1]
        ld      bc,$0010
        call    :_LABEL_7CC1_12
        ret
        
        ;sprite layout
._b5b5  BYTE    $FE, $FF, $FF, $FF, $FF, $FF
        BYTE    $6C, $6E, $6C, $6E, $FF, $FF
        BYTE    $FF
}

PROC    :_b5c2                                  SECTION ::mobs                  ;$B5C2
        ;===============================================================================
PARAMS  IX`mob          ``Address of the current mob being processed
{
        push    BC  DE
        call    :findEmptyMob
        pop     DE  BC
        ret     c
        
        push    IX  HL
        ld      L               [IX`mob+#mob.X+0]
        ld      H               [IX`mob+#mob.X+1]
        add     HL              DE
        ex      DE              HL
        ld      L               [IX`mob+#mob.Y+0]
        ld      H               [IX`mob+#mob.Y+1]
        add     HL              BC
        ld      C               L
        ld      B               H
        pop     IX
        xor     A`zero                          ;set A to 0
        ld      [IX`mob+#mob.type]      $0D     ;unknown mob?
        ld      [IX`mob+#mob.Xsubpixel] A`zero
        ld      [IX`mob+#mob.X+0]       E
        ld      [IX`mob+#mob.X+1]       D
        ld      [IX`mob+#mob.Ysubpixel] A`zero
        ld      [IX`mob+#mob.Y+0]       C
        ld      [IX`mob+#mob.Y+1]       B
        ld      [IX`mob+#mob.unknown11] A`zero
        ld      [IX`mob+#mob.unknown13] A`zero
        ld      [IX`mob+#mob.unknown14] A`zero
        ld      [IX`mob+#mob.unknown15] A`zero
        ld      [IX`mob+#mob.unknown16] A`zero
        ld      [IX`mob+#mob.unknown17] A`zero
        ld      HL              [$.TEMP4]
        bit     7  H
        jr      z  ._1
        ld      A                       $FF
._1     ld      [IX`mob+#mob.Xspeed+0]      L
        ld      [IX`mob+#mob.Xspeed+1]      H
        ld      [IX`mob+#mob.Xdirection]    A
        xor     A`zero
        ld      HL              [$.TEMP6]
        bit     7  H
        jr      z  ._2
        ld      A               $FF
._2     ld      [IX`mob+#mob.Yspeed+0]      L
        ld      [IX`mob+#mob.Yspeed+1]      H
        ld      [IX`mob+#mob.Ydirection]    A
        pop     IX
        ld      A               $01
        rst     :rst_playSFX
        ret
}

INCLUDE "mobs\boss_skybase.oz80"

INCLUDE "mobs\unknown_bcdf.oz80"
INCLUDE "mobs\anim_final.oz80"
INCLUDE "mobs\anim_emeralds.oz80"